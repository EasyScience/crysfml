============================== 
CrysFML High Level Procedures
==============================
Here is a minimal set of types and procedures to be exposed for Python use of CrysFML. The best way of working
may be the use of Forpy as an intermediate library. The simplest mechanism is to convert types into "dictionaries" and
create a Fortran module with wrappers for the selected subroutines. The use of numpy is compulsory. 
Mathematical procedures, parsing of refinement instructions, as well as optimization techniques have been excluded 
in this first stage.

======================================
CFML_GlobalDeps: (CFML_GlobalDeps.f90)
======================================
Globals:
--------
   integer, parameter :: sp = selected_real_kind(6,30)
   integer, parameter :: dp = selected_real_kind(14,150)
   integer, parameter :: cp = sp

Subroutines:
------------
   Subroutine Write_Date_Time(lun,dtim)
     integer,         optional,intent(in) :: lun
     character(len=*),optional,intent(out):: dtim

===================================================
CFML_Crystallographic_Symmetry: (CFML_Symmetry.f90)
===================================================

Globals:
--------
    logical, public :: Err_Symm
    character(len=150), public :: ERR_Symm_Mess

Types: 
------
    Type, public :: Sym_Oper_Type
       integer,       dimension(3,3) :: Rot
       real(kind=cp), dimension(3)   :: Tr
    End Type Sym_Oper_Type

    Type, public :: Space_Group_Type
       integer                                       :: NumSpg=0         ! Number of the Space Group
       character(len=20)                             :: SPG_Symb=" "     ! Hermann-Mauguin Symbol
       character(len=16)                             :: Hall=" "         ! Hall symbol
       character(len=90)                             :: gHall=" "        ! Generalised Hall symbol
       character(len=12)                             :: CrystalSys=" "   ! Crystal system
       character(len= 5)                             :: Laue=" "         ! Laue Class
       character(len= 5)                             :: PG=" "           ! Point group
       character(len= 5)                             :: Info=" "         ! Extra information
       character(len=90)                             :: SG_setting=" "   ! Information about the SG setting (IT,KO,ML,ZA,Table,Standard,UnConventional)
       logical                                       :: Hexa=.false.     !
       character(len= 1)                             :: SPG_lat=" "      ! Lattice type
       character(len= 2)                             :: SPG_latsy=" "    ! Lattice type Symbol
       integer                                       :: NumLat=0         ! Number of lattice points in a cell
       real(kind=cp), allocatable,dimension(:,:)     :: Latt_trans       ! Lattice translations (3,12)
       character(len=51)                             :: Bravais=" "      ! String with Bravais symbol + translations
       character(len=80)                             :: Centre=" "       ! Alphanumeric information about the center of symmetry
       integer                                       :: Centred=0        ! Centric or Acentric [ =0 Centric(-1 no at origin),=1 Acentric,=2 Centric(-1 at origin)]
       real(kind=cp), dimension(3)                   :: Centre_coord=0.0 ! Fractional coordinates of the inversion centre
       integer                                       :: NumOps=0         ! Number of reduced set of S.O.
       integer                                       :: Multip=0         ! Multiplicity of the general position
       integer                                       :: Num_gen          ! Minimum number of operators to generate the Group
       type(Sym_Oper_Type), allocatable,dimension(:) :: SymOp            ! Symmetry operators (192)
       character(len=50),   allocatable,dimension(:) :: SymopSymb        ! Strings form of symmetry operators
       type(Wyckoff_Type)                            :: Wyckoff          ! Wyckoff Information
       real(kind=cp),dimension(3,2)                  :: R_Asym_Unit=0.0  ! Asymmetric unit in real space
    End Type Space_Group_Type

    Type, public :: MSym_Oper_Type
       integer, dimension(3,3) :: Rot
       real(kind=cp)           :: Phas
    End Type MSym_Oper_Type

    Type, Public :: Magnetic_Space_Group_Type
       Integer                                        :: Sh_number=0
       character(len=15)                              :: BNS_number=" "
       character(len=15)                              :: OG_number=" "
       Character(len=34)                              :: BNS_symbol=" "
       Character(len=34)                              :: OG_symbol=" "
       Character(len=34)                              :: PG_symbol=" "
       Integer                                        :: MagType=0
       Integer                                        :: Parent_num=0
       Character(len=20)                              :: Parent_spg=" "
       logical                                        :: standard_setting=.false.  !true or false
       logical                                        :: mcif=.false.     !true if mx,my,mz notation is used , false is u,v,w notation is used
       logical                                        :: m_cell=.true.    !true if magnetic cell is used for symmetry operators
       logical                                        :: m_constr=.false. !true if constraints have been provided
       Character(len=80)                              :: trn_to_parent=" "
       Character(len=80)                              :: trn_from_parent=" "
       Character(len=80)                              :: trn_to_standard=" "
       Character(len=80)                              :: trn_from_standard=" "
       character(len=12)                              :: CrystalSys=" "       ! Crystal system
       character(len= 3)                              :: SPG_lat=" "          ! Lattice type
       character(len= 4)                              :: SPG_latsy=" "        ! Lattice type Symbol
       integer                                        :: Num_Lat          ! Number of lattice points in a cell
       integer                                        :: Num_aLat         ! Number of anti-lattice points in a cell
       real(kind=cp), allocatable,dimension(:,:)      :: Latt_trans       ! Lattice translations
       real(kind=cp), allocatable,dimension(:,:)      :: aLatt_trans      ! Lattice anti-translations
       character(len=80)                              :: Centre=" "           ! Alphanumeric information about the center of symmetry
       integer                                        :: Centred          ! Centric or Acentric [ =0 Centric(-1 no at origin),=1 Acentric,=2 Centric(-1 at origin)]
       real(kind=cp), dimension(3)                    :: Centre_coord     ! Fractional coordinates of the inversion centre
       integer                                        :: NumOps           ! Number of reduced set of S.O. (removing lattice centring and anticentrings and centre of symmetry)
       Integer                                        :: Multip
       integer                                        :: Num_gen          ! Minimum number of operators to generate the Group
       Integer                                        :: n_wyck           ! Number of Wyckoff positions of the magnetic group
       Integer                                        :: n_kv             ! Number of propagation vectors
       Integer                                        :: n_irreps
       Integer,             dimension(:),allocatable  :: irrep_dim          ! Dimension of the irreps
       Integer,             dimension(:),allocatable  :: small_irrep_dim    ! Dimension of the small irrep
       Integer,             dimension(:),allocatable  :: irrep_modes_number ! Number of the mode of the irrep
       Character(len=15),   dimension(:),allocatable  :: irrep_id           ! Labels for the irreps
       Character(len=20),   dimension(:),allocatable  :: irrep_direction    ! Irrep direction in representation space
       Character(len=20),   dimension(:),allocatable  :: irrep_action       ! Irrep character primary or secondary
       Character(len=15),   dimension(:),allocatable  :: kv_label
       real(kind=cp),     dimension(:,:),allocatable  :: kv
       character(len=40),   dimension(:),allocatable  :: Wyck_Symb  ! Alphanumeric Symbols for first representative of Wyckoff positions
       character(len=40),   dimension(:),allocatable  :: SymopSymb  ! Alphanumeric Symbols for SYMM
       type(Sym_Oper_Type), dimension(:),allocatable  :: SymOp      ! Crystallographic symmetry operators
       character(len=40),   dimension(:),allocatable  :: MSymopSymb ! Alphanumeric Symbols for MSYMM
       type(MSym_Oper_Type),dimension(:),allocatable  :: MSymOp     ! Magnetic symmetry operators
    End Type Magnetic_Space_Group_Type

Functions:
----------
    Function Lattice_Trans(V,Lat) Result(Lattice_Transl)  !Determine is vector V is a lattice translation
       real(kind=cp), dimension(3), intent( in) :: v
       character(len=*),            intent( in) :: Lat    !Symbol of the lattice: P,A,B,C,I,F,R
       logical                                  :: Lattice_Transl

    Function Get_Multip_Pos(x,Spg) Result(mult)  !Get multiplicity of position x in the space group spg
       real(kind=cp), dimension(3),  intent (in) :: x
       type(Space_Group_type),       intent (in) :: Spg
       integer                                   :: mult

    Function Get_Occ_Site(Pto,Spg) Result(Occ)   ! Get the occupation factor m/M of position Pto in the space group Spg
       real(kind=cp), dimension(3),intent(in) :: Pto
       type (Space_Group_Type),    intent(in) :: Spg
       real(kind=cp)                          :: Occ

Subroutines: (the procedures for constructing magnetic goups are given in other modules)
------------    
    Subroutine Set_SpaceGroup(Spacegen,Spacegroup,Gen,Ngen,Mode,Force_Hall) !Construct the space group Spacegroup
       character (len=*),                intent(in )           :: SpaceGen
       Type (Space_Group_Type),          intent(out)           :: SpaceGroup
       character (len=*), dimension(:),  intent(in ), optional :: gen
       Integer,                          intent(in ), optional :: ngen
       character (len=*),                intent(in ), optional :: Mode
       character (len=*),                intent(in ), optional :: force_hall

    Subroutine Write_SpaceGroup(SpaceGroup,Iunit,Full)   !Write SpaceGroup into unit Iunit
       type (Space_Group_Type),intent(in) :: SpaceGroup
       integer,   optional,    intent(in) :: iunit
       logical,   optional,    intent(in) :: full

    Subroutine Write_Magnetic_Space_Group(SG,Iunit,full) !Write magnetic space group SG into unit Iunit
       type (Magnetic_Space_Group_Type),intent(in) :: SG
       integer,   optional,             intent(in) :: iunit
       logical,   optional,             intent(in) :: full
       
============================================       
CFML_Crystal_Metrics: (CFML_Cryst_Types.f90)
============================================
Globals:
--------
    logical, public  :: ERR_Crys
    character(len=150), public :: ERR_Crys_Mess

Types:
------
    Type, public :: Crystal_Cell_Type
       real(kind=cp),dimension(3)   :: cell, ang          ! Direct cell parameters
       integer,      dimension(3)   :: lcell, lang        ! Code number for refinement in optimization procedures
       real(kind=cp),dimension(3)   :: cell_std, ang_std  ! Standar deviations cell parameters
       real(kind=cp),dimension(3)   :: rcell,rang         ! Reciprocal cell parameters
       real(kind=cp),dimension(3,3) :: GD,GR              ! Direct and reciprocal Metric Tensors
       real(kind=cp),dimension(3,3) :: Cr_Orth_cel        ! P-Matrix transforming Orthonormal
                                                          ! basis to direct Crytal cell (as I.T.)
                                                          ! (or crystallographic components to
                                                          !  Cartesian components: XC = Cr_Orth_cel X -> XC,X: column vectors)
       real(kind=cp),dimension(3,3) :: Orth_Cr_cel        ! Inv(Cr_Orth_cel) -> Cartesian to cryst. components
       real(kind=cp),dimension(3,3) :: BL_M               ! Busing-Levy B-matrix (transforms hkl to  a
                                                            Cartesian system with x//a*, y in (a*,b*) and z//c
       real(kind=cp),dimension(3,3) :: BL_Minv            ! Inverse of the Busing-Levy B-matrix
       real(kind=cp)                :: CellVol            ! Direct and Reciprocal
       real(kind=cp)                :: RCellVol           ! Cell volumes
       real(kind=cp)                :: StdVol             ! Sigma for Cell
       Character (len=2)            :: CartType           ! Cartesian Frame type: if CartType='A'
                                                          ! the Cartesian Frame has x // a.
    End Type Crystal_Cell_Type

    Type, public :: Twofold_Axes_Type
       integer                       :: ntwo        ! Number of two-fold axes
       real(kind=cp)                 :: tol         ! Angular tolerance (ca 3 degrees)
       real(kind=cp),dimension(3,12) :: caxes       ! Cartesian components of two-fold axes
       integer,dimension(3,12)       :: dtwofold    ! Direct indices of two-fold axes
       integer,dimension(3,12)       :: rtwofold    ! Reciprocal indices of two-fold axes
       integer,dimension(12)         :: dot         ! Scalar product of reciprocal and direct indices
       real(kind=cp),dimension(12)   :: cross       ! Angle between direct and reciprocal axes ( < tol)
       real(kind=cp),dimension(12)   :: maxes       ! Modulus of the zone axes (two-fold axes) vectors
       real(kind=cp),dimension(3)    :: a,b,c       ! Cartesian components of direct cell parameters
    End Type Twofold_Axes_Type
    
Functions:
----------

    Function Cart_Vector(Code,V,Celda) Result(Vc)  !Convert a vector in crystal space to Cartesian components
       character (len=*),             intent(in) :: code     !  In -> D: Direct, R: Reciprocal
       real(kind=cp), dimension(3),   intent(in) :: v        !  In -> Vector
       Type (Crystal_Cell_Type),      intent(in) :: Celda    !  In -> Cell variable
       real(kind=cp) dimension(3)                :: vc       ! Out ->
       
    Function Cart_U_Vector(Code,V,Celda) Result(Vc)  !Convert a vector in crystal space to unitary Cartesian components
        character (len=*),             intent(in) :: code    !  In -> D: Direct, R: Reciprocal
        real(kind=cp), dimension(3),   intent(in) :: v       !  In -> Vector
        Type (Crystal_Cell_Type),      intent(in) :: Celda   !  In -> Cell Variable
        real(kind=cp),dimension(3)                :: vc      ! Out ->

    Function Get_Betas_from_Biso(Biso,Cell) Result(Betas) !Get Betas from Biso
       real(kind=cp),             intent(in)  :: Biso
       type (Crystal_cell_Type),  intent(in)  :: Cell
       real(kind=cp),dimension(6)             :: Betas
        
    
Subroutines:
------------
    Subroutine Set_Crystal_Cell(Cellv,Angl,Celda,Cartype,Scell,Sangl)
       real(kind=cp), dimension (3),        intent(in ) :: cellv   !  In -> a,b,c
       real(kind=cp), dimension (3),        intent(in ) :: angl    !  In -> angles of cell parameters
       Type (Crystal_Cell_Type),            intent(out) :: Celda   !  Out-> Celda components
       character (len=1),          optional,intent(in ) :: CarType !  In -> Type of Cartesian Frame
       real(kind=cp), dimension(3),optional,intent(in ) :: scell,sangl !Standard deviations of cell parameters

    Subroutine Change_Setting_Cell(Cell,Mat,Celln,Matkind) ! Calculates a new cell giving the transformation matrix M
       type (Crystal_Cell_Type),      intent( in)    :: Cell !input Cell
       real(kind=cp), dimension (3,3),intent( in)    :: Mat  !Transformation matrix to obtain Celln
       type (Crystal_Cell_Type),      intent(out)    :: Celln
       character (len=*), optional,   intent (in)    :: matkind !If matkind="IT" the Mat=S

    Subroutine Write_Crystal_Cell(Celda,Lun) !Writes the cell characteristics in the file associated to the logical unit lun
       Type (Crystal_Cell_Type),  intent(in)  :: Celda   !  In -> Cell variable
       Integer,optional           intent(in)  :: lun     !  In -> Unit to write
        
    Subroutine Calc_Cell_Strain(itype,T0,T1,strain) 
       integer,      intent(in)                 ::  itype  ! strain type (1: Eulerian finite, 2:Eulerian infinitesimal, 3:Lagrangian finite, 4:Lagrangian infinitesimal)
       real(kind=cp),intent(in), dimension(3,3) ::  T0     ! CR_Orth_Cel for chosen axial system for the starting state
       real(kind=cp),intent(in), dimension(3,3) ::  T1     ! CR_Orth_Cel for chosen axial system for the final state
       real(kind=cp),intent(out),dimension(3,3) ::  strain ! calculated cell strain

    Subroutine Get_TwoFold_Axes(Cell,Tol,Twofold) !Provides the type Twofold from Cell within angular tolerance Tol
       type(Crystal_Cell_Type), intent (in) :: Cell
       real(kind=cp),           intent (in) :: tol !angular tolerance in degrees
       Type(Twofold_Axes_Type), intent(out) :: twofold
    
    Subroutine Get_Conventional_Cell(Twofold,Cell,Tr,Message,Ok,told) !Provides the convention cell form Twofold type
      Type(Twofold_Axes_Type), intent(in)  :: twofold                 
      Type(Crystal_Cell_Type), intent(out) :: Cell  !Conventional cell
      integer, dimension(3,3), intent(out) :: tr    !Transformation Matrix between cell encoded within TwoFold and the conventional cell
      character(len=*),        intent(out) :: message
      logical,                 intent(out) :: ok
      real(kind=cp), optional, intent(in)  :: told  !Tolerance in angstroms (default: 0.2)

=======================================
CFML_Atom_TypeDef:  (CFML_Atom_Mod.f90)
=======================================
In this module the types can be exposed partially. For instance, components of like mx,lx,mocc,locc,mvar,lvar, etc. need
not to be exposed if refinements are not used.

Globals:
-------
    logical, public  :: ERR_Atmd
    character(len=150), public :: Err_Atmd_Mess


Types: 
------
     Type, Public :: Atom_Equiv_Type
        integer                                        :: mult
        character(len=2)                               :: ChemSymb
        character(len=20),allocatable, dimension(:)    :: Lab
        real(kind=cp),    allocatable, dimension(:,:)  :: x
     End Type Atom_Equiv_Type
     
     Type, Public :: Atom_Equiv_List_Type
        integer                                           :: nauas
        type (Atom_Equiv_Type), allocatable, dimension(:) :: atm
     End Type Atom_Equiv_List_Type

    Type, public :: Atom_Type
       character(len=20)                       :: Lab           ! Label
       character(len=2)                        :: ChemSymb      ! Chemical Symbol
       character(len=4)                        :: SfacSymb      ! Symbol for Scattering Factor
       character(len=1)                        :: wyck          ! Wyckoff letter
       logical                                 :: active        ! Control for different purposes
       integer                                 :: Z             ! Atomic number
       integer                                 :: mult          ! multiplicity of the site
       real(kind=cp),dimension(3)              :: x             ! Fractional coordinates
       real(kind=cp),dimension(3)              :: x_std         ! Standard deviations
       real(kind=cp),dimension(3)              :: mx            ! Multiplier parameters of coordinates
       integer,      dimension(3)              :: lx            ! Numbers in the LSQ list of LSQ parameters for coordinates
       real(kind=cp)                           :: occ           ! occupation factor
       real(kind=cp)                           :: occ_std       ! Standard deviation of occupation factor
       real(kind=cp)                           :: mOcc          !
       integer                                 :: lOcc          !
       real(kind=cp)                           :: Biso          ! Isotropic B-factor
       real(kind=cp)                           :: Biso_std      ! Standard deviation of Isotropic B-factor
       real(kind=cp)                           :: mBiso         !
       integer                                 :: lBiso         !
       character(len=4)                        :: utype         ! type of anisotropic thermal parameters: u_ij, b_ij, beta, none
       character(len=5)                        :: thtype        ! "isotr","aniso","other"
       real(kind=cp),dimension(6)              :: U             ! U11, U22, U33, U12, U13, U23
       real(kind=cp),dimension(6)              :: U_std         ! Standar_Deviations of U"s
       real(kind=cp)                           :: Ueq           ! Uequiv
       real(kind=cp),dimension(6)              :: mU            !
       integer,dimension(6)                    :: lU            !
       real(kind=cp)                           :: Charge        ! Charge
       real(kind=cp)                           :: Moment        ! Moment
       integer, dimension(5)                   :: Ind           ! Index for different purposes
       integer                                 :: Nvar          !
       real(kind=cp),dimension(25)             :: VarF          ! Free variables used for different purposes (1,2,3 reserved for occupations, not refinable)
       real(kind=cp),dimension(25)             :: MVarF         ! Multiplier parameters
       integer,      dimension(25)             :: LVarF         ! Numbers
       character(len=40)                       :: AtmInfo       ! Information string
    End Type Atom_Type
    
    Type, public :: Atom_List_Type
       integer                                  :: natoms
       type(Atom_Type),dimension(:),allocatable :: atom
    End type Atom_List_Type

    Type, public :: mAtom_Type
       character(len=10)                       :: Lab           ! Label
       character(len=2)                        :: ChemSymb      ! Chemical Symbol
       character(len=4)                        :: SfacSymb      ! Chemical Symbol for SF
       character(len=1)                        :: wyck          ! Wyckoff letter
       logical                                 :: active        ! Control for different purposes
       integer                                 :: Z             ! Atomic number
       integer                                 :: mult          ! multiplicity of the site
       real(kind=cp),dimension(3)              :: x             ! Fractional coordinates
       real(kind=cp),dimension(3)              :: x_std         ! Standar deviations
       real(kind=cp),dimension(3)              :: mx            ! Multiplier parameters of coordinates
       integer,      dimension(3)              :: lx            ! Numbers of LSQ parameters for coordinates
       real(kind=cp)                           :: occ           ! occupation factor
       real(kind=cp)                           :: occ_std       ! Standard deviation of occupation factor
       real(kind=cp)                           :: mOcc          !
       integer                                 :: lOcc          !
       real(kind=cp)                           :: Biso          ! Isotropic B-factor
       real(kind=cp)                           :: Biso_std      ! Standard deviation of Isotropic B-factor
       real(kind=cp)                           :: mBiso         !
       integer                                 :: lBiso         !
       character(len=4)                        :: utype         ! type of anisotropic thermal parameters: u_ij, b_ij, beta, none
       character(len=5)                        :: thtype        ! "isotr","aniso","other"
       real(kind=cp),dimension(6)              :: U             ! U11, U22, U33, U12, U13, U23
       real(kind=cp),dimension(6)              :: U_std         ! Standar_Deviations of U"s
       real(kind=cp)                           :: Ueq           ! Uequiv
       real(kind=cp),dimension(6)              :: mU            !
       real(kind=cp),dimension(6)              :: lU            !
       real(kind=cp)                           :: Charge        ! Charge
       real(kind=cp)                           :: Moment        ! Moment
       integer, dimension(5)                   :: Ind           ! Index for different purposes
       integer                                 :: Nvar          !
       real(kind=cp),dimension(25)             :: VarF          ! Free parameters to load
       real(kind=cp),dimension(25)             :: mVarF
       integer,      dimension(25)             :: LVarF
       character(len=40)                       :: AtmInfo       ! Information string
                              ===================
                              Magnetic parameters
                              ===================
       integer                                 :: nvk           ! Number of propagation vectors (excluding -k)
       integer,      dimension(12)             :: imat          ! Number of the magnetic matrices/irrep set to be applied
       real(kind=cp),dimension(3,12)           :: SkR           ! Real part of Fourier Coefficient
       real(kind=cp),dimension(3,12)           :: SkR_std       ! Standard deviations of the Real part of Fourier Coefficient
       real(kind=cp),dimension(3,12)           :: Spher_SkR     ! Real part of Fourier Coefficient in spherical components
       real(kind=cp),dimension(3,12)           :: Spher_SkR_std ! Standard deviations of Real part of Fourier Coefficient in spherical components
       real(kind=cp),dimension(3,12)           :: mSkR          ! Multipliers for the real part of Fourier coefficients
       integer,      dimension(3,12)           :: lskr          ! Numbers in the list of LSQ parameters
       real(kind=cp),dimension(3,12)           :: SkI           ! Imaginary part of Fourier Coefficient
       real(kind=cp),dimension(3,12)           :: SkI_std       ! Standard deviations of Imaginary part of Fourier Coefficient
       real(kind=cp),dimension(3,12)           :: Spher_SkI     ! Imaginary part of Fourier Coefficient in spherical components
       real(kind=cp),dimension(3,12)           :: Spher_SkI_std ! Standard deviations of Imaginary part of Fourier Coefficient in spherical components
       real(kind=cp),dimension(3,12)           :: mSki          ! Multipliers for the imaginary part of Fourier coefficients
       integer,      dimension(3,12)           :: lski          ! Numbers in the list of LSQ parameters
       real(kind=cp),dimension(12)             :: mphas         ! Magnetic Phase in fractions of 2pi
       real(kind=cp),dimension(12)             :: mphas_std     ! Standard deviations of Magnetic Phase in fractions of 2pi
       real(kind=cp),dimension(12)             :: mmphas        ! Multiplier for the magnetic phase
       integer,dimension(12)                   :: lmphas        ! Number in the list of LSQ parameters
       real(kind=cp),dimension(12,12)          :: cbas          ! Coefficients of the basis functions of irreps, the second index is 1:nvk
       real(kind=cp),dimension(12,12)          :: cbas_std      ! Standard deviations of Coefficients of the basis functions of irreps, the second index is 1:nvk
       real(kind=cp),dimension(12,12)          :: mbas          ! multiplier for the coefficients of the basis functions of irreps
       integer,dimension(12,12)                :: lbas          ! Numbers in the list of LSQ parameters
       character(len=5)                        :: chitype       ! "isotr","aniso"
       real(kind=cp),dimension(6)              :: chi           ! chi11, chi22, chi33, chi12, chi13, chi23
       real(kind=cp),dimension(6)              :: chi_std       ! Standar_Deviations of chi's
       real(kind=cp)                           :: Chieq         ! Chi equiv
       real(kind=cp),dimension(6)              :: mchi          !
       real(kind=cp),dimension(6)              :: lchi          !
    End Type mAtom_Type

    Type, public :: mAtom_List_Type
       integer                                   :: natoms
       logical                                   :: suscept    ! true if magnetic moments are calculated from local susceptibility
       real(kind=cp)                             :: MagField   ! Applied magnetic field strength in Tesla
       real(kind=cp), dimension(3)               :: dir_MField ! Direction of magnetic field in crystallographic system
       type(mAtom_Type),dimension(:),allocatable :: Atom
    End type mAtom_List_Type

    Type, public :: atoms_cell_type
       integer                                      :: nat         ! -> Total number of atoms
       character(len=20), dimension(:), allocatable :: noms        ! -> Name of atoms   (nat)
       real(kind=cp),   dimension(:,:), allocatable :: xyz         ! -> Fractional coordinates (3,nat)
       real(kind=cp),     dimension(:), allocatable :: charge
       real(kind=cp),     dimension(:), allocatable :: moment
       real(kind=cp),   dimension(:,:), allocatable :: Var_free    ! -> Free variables (10,nat)
       integer,           dimension(:), allocatable :: neighb      ! -> Number of neighbours (nat)
       integer,        dimension( :,:), allocatable :: neighb_atom ! -> Ptr.->neighbour (# in list)(nat,idp)
       real(kind=cp),  dimension( :,:), allocatable :: distance    ! -> Corresponding distances (nat,idp)
       real(kind=cp),dimension(:, :,:), allocatable :: trans       ! -> Lattice translations   (3,nat,idp)
       integer                                      :: ndist       ! -> Number of distinct distances
       real(kind=cp),     dimension(:), allocatable :: ddist       ! -> List of distinct distances(nat*idp)
       character(len=20), dimension(:), allocatable :: ddlab       ! -> Labels of atoms at ddist (nat*idp)
    End Type atoms_cell_type

Subroutines:
------------
    Subroutine Atom_Uequi_List(Cell, Ac)
       type(Crystal_Cell_Type), intent(in)    :: Cell    !  In -> Cell variable
       type(atom_list_type),   intent(in out) :: Ac      !  In -> Atom list, Out -> updated Ac
                                                             
    Subroutine Atoms_Cell_To_List(Ac,A)
       Type(atoms_cell_type),  Intent(In)        :: Ac   !  In -> instance of atoms_cell_type
       type(atom_list_type),   intent(in out)    :: A    !  In -> instance of atom_list_type
                                                            Out-> Initialize atom_list_type components
    Subroutine Multi(Lun,Iprin,Conven,Spg,A,Ac)
       integer,                intent(in)     :: lun     !  In -> Logical Unit for writing
       logical,                intent(in)     :: iprin   !  In -> .true. for writing in Lun
       logical,                intent(in)     :: conven  !  In -> .true. for using the whole conventional unit cell
       type(Space_Group_Type), intent(in)     :: SpG     !  In -> Space Group Information
       type(atom_list_type),  intent(in out)  :: A       !  In -> Atom List (asymmetric unit)
                                                           Out -> Updated Atom List (multiplicity of sites)
       type(atoms_cell_type),  intent(out)    :: Ac      ! Out -> Atoms in unit cell

    Subroutine Set_Atom_Equiv_List(SpG,cell,A,Ate,lun)
       type(Crystal_Cell_Type),    intent(in) :: Cell
       type(Space_Group_Type) ,    intent(in) :: SpG
       type(Atom_list_Type)   ,    intent(in) :: A
       type(Atom_Equiv_List_Type), intent(out):: Ate
       integer, optional,          intent(in) :: lun

    Subroutine Write_Atom_List(Ats,Level,Lun,Cell)
       Type (atom_list_type),dimension(:),  intent(in) :: Ats     !  In -> Atom List
       integer, optional,                   intent(in) :: Level   !  In -> Level of printed information
       integer, optional,                   intent(in) :: lun     !  In -> Unit to write
       Type(Crystal_Cell_Type), optional,   intent(in) :: Cell    !  In -> Used to Transform thermal parameters

    Subroutine Get_Atom_2nd_Tensor_Ctr(x,TensVal,Spgr,Codini,Icodes,Multip,Ord,Ss,Ipr)
       real(kind=cp), dimension(3),             intent(in    ) :: x         !Atom position (fractional coordinates)
       real(kind=cp), dimension(6),             intent(in out) :: TensVal   !Second order symmetric tensor
       type(Space_Group_type),                  intent(ix    ) :: Spgr      !Space Group
       Integer,                                 intent(in out) :: Codini    !Last attributed parameter
       Integer, dimension(6),                   intent(in out) :: Icodes    !codewords for TensVal only number
       real(kind=cp), dimension(6),             intent(in out) :: Multip    !Multipliers
       integer,                       optional, intent(in    ) :: Ord       !Order of the stabilizer
       integer, dimension(:),         optional, intent(in    ) :: Ss        !Pointer to SymmOp. of stabilizer
       integer,                       optional, intent(in    ) :: Ipr       !Printing unit for debug

=======================================================
CFML_Scattering_Chemical_Tables:  (CFML_Chem_Scatt.f90)
=======================================================

Types:
------
    Type, public :: Anomalous_Sc_Type
       character(len= 2)            :: Symb        ! Symbol of the Element
       real(kind=cp), dimension(5)  :: Fp           
       real(kind=cp), dimension(5)  :: Fpp
    End Type Anomalous_Sc_Type
    
    Type, public :: Chem_Info_Type
       character (len= 2)         :: Symb          ! Symbol of the Element
       character (len=12)         :: Name          ! Name of the Element
       integer                    :: Z             ! Atomic Number
       real(kind=cp)              :: AtWe          ! Atomic weight
       real(kind=cp)              :: RCov          ! Covalent Radius
       real(kind=cp)              :: RWaals        ! van der Waals Radius
       real(kind=cp)              :: VAtm          ! Atomic volumen
       integer, dimension(5)      :: Oxid          ! Oxidation State
       real(kind=cp), dimension(5):: Rion          ! Ionic Radius (depending of the oxidation)
       real(kind=cp)              :: SctF          ! Fermi length [10**(-12) cm]
       real(kind=cp)              :: SedInc        ! Incoherent Scattering Neutron cross-section (barns -> [10**(-24) cm**2] )
       real(kind=cp)              :: Sea           ! Neutron Absorption cross-section ( barns, for v= 2200m/s, l(A)=3.95/v (km/s) )
    End Type Chem_Info_Type
 
    Type, public :: Magnetic_Form_Type
       character (len= 4)         :: Symb         ! Symbol of the Chemical species
       real(kind=cp), dimension(7):: SctM         ! Scattering Factors coefficients (a1,b1,a2,b2,a3,b3,c)
    End Type Magnetic_Form_Type

    Type, public :: Xray_Form_Type
       character (len= 4)         :: Symb  ! Symbol of the Chemical species
       integer                    :: Z     ! Atomic Number
       real(kind=cp), dimension(4):: a     ! Coefficients for calculating the X-ray scattering factors
       real(kind=cp), dimension(4):: b     ! f(s) = Sum_{i=1,4} { a(i) exp(-b(i)*s^2) } + c
       real(kind=cp)              :: c     ! s=sinTheta/Lambda
    End Type Xray_Form_Type

    Type, public :: Xray_Wavelength_Type
       character (len= 2)                :: Symb  ! Symbol of the Chemical species
       real(kind=cp), dimension(2)       :: Kalfa ! K-Serie for X-ray
       real(kind=cp)                     :: Kbeta ! K-Serie for X-ray
    End Type Xray_Wavelength_Type

 Subroutines:
 ------------
     Subroutine Get_Atomic_Mass(atm,mass)
       character(len=2), intent (in) :: atm
       real(kind=cp),    intent(out) :: Mass

    Subroutine Get_Atomic_Vol(atm,vol)
       character(len=2), intent (in) :: atm
       real(kind=cp),    intent(out) :: Vol
       
    Subroutine Get_ChemSymb(Label, ChemSymb, Z)
      character(len=*),  intent(in) :: Label    ! Label
      character(len=*),  intent(out):: ChemSymb ! Chemical Symbol
      integer, optional, intent(out):: Z        ! Atomic number

    Subroutine Get_Covalent_Radius(nam,rad)
       character(len=*), intent (in) :: nam
       real(kind=cp),    intent(out) :: rad
       
    Subroutine Get_Fermi_Length(nam,b) 
       character(len=*), intent (in) :: nam
       real(kind=cp),    intent(out) :: b
 
    Subroutine Get_Inc_Xs(nam,u) !Provides incoherent scattering neutron cross-section (barns -> [10**(-24) cm**2] )
       character(len=*), intent (in) :: nam
       real(kind=cp),    intent(out) :: u

    Subroutine Get_Abs_Xs(nam,u) !Provides the absorption cross-section ( barns, for v= 2200m/s, l(A)=3.95/v (km/s) )
       character(len=*), intent (in) :: nam
       real(kind=cp),    intent(out) :: u
    
    Subroutine Get_Ionic_Radius(nam,valence,rad)
       character(len=*), intent (in) :: nam
       integer,          intent (in) :: valence
       real(kind=cp),    intent(out) :: rad
       
    Subroutine Set_Chem_Info()
    
    Subroutine Set_Delta_Fp_Fpp()
    
    Subroutine Set_Magnetic_Form()
    
    Subroutine Set_Xray_Form()
    
    Subroutine Remove_Chem_Info()
    
    Subroutine Remove_Delta_Fp_Fpp()
    
    Subroutine Remove_Magnetic_Form()
    
    Subroutine Remove_Xray_Form()

=============================================
CFML_String_Utilities: (CFML_String_Util.f90)
=============================================

Python has many functions for treating strings, so only a part of this module should be exposed to Python. Here we give
a series of utility subroutines that may be useful.

Global:
-------
    logical, public :: ERR_String
    character(len=150), public :: ERR_String_Mess
    
Types:
------
    none

Subroutines:
------------
    Subroutine Get_Fraction_1Dig(V,Fracc)
       real(kind=cp),      intent( in) :: V       !  In -> Input real number
       character (len=*),  intent(out) :: Fracc   ! Out -> Fracction in character form

    Subroutine Get_Fraction_2Dig(V,Fracc)
       real(kind=cp),      intent( in) :: V       !  In -> Input real number
       character (len=*),  intent(out) :: Fracc   ! Out -> Fracction in character form

    Subroutine Get_Mat_From_Symb(Symb,Mat,cod)  !Generates a matrix from the symbol:  m1a+m2b+m3c,m4a+m5b+m6c,m7a+m8b+m9c
      character(len=*),                intent(in)  :: Symb
      real,dimension(3,3),             intent(out) :: Mat
      character(len=1), dimension(3),  intent(in)  :: cod !cod=["a","b","c"] or cod=["u","v","w"] or cod=["x","y","z"]

    Subroutine Get_Symb_From_Mat(Mat,Symb,cod)  !Constructs a symbol of the form:  m1a+m2b+m3c,m4a+m5b+m6c,m7a+m8b+m9c
      real,dimension(3,3),             intent(in)   :: Mat
      character(len=*),                intent(out)  :: Symb
      character(len=1), dimension(3),  intent(in)   :: cod !cod=["a","b","c"] or cod=["u","v","w"] or cod=["x","y","z"]

    Subroutine Get_Transf(string,mat,v,cod) !Generates the transformation matrix and vector from symbol:  m1a+m2b+m3c,m4a+m5b+m6c,m7a+m8b+m9c;t1,t2,t3
      character(len=*),                         intent(in)  :: string
      real(kind=cp),dimension(3,3),             intent(out) :: mat
      real(kind=cp),dimension(3),               intent(out) :: v
      character(len=1), optional,dimension(4),  intent(in)  :: cod

    Subroutine SetNum_Std(Value, Std, Line) !Convert value and Std to a string of the form: value(Std) using a maximum of two digits for Std
       real(kind=cp),   intent(in)  :: Value
       real(kind=cp),   intent(in)  :: Std
       character(len=*),intent(out) :: Line

    Subroutine GetNum_Std(line, value, std, ic) !Read real values from a string of the form: 0.123(2) 1.23(1) 3.322(56) ...
       character(len=*),             intent( in) :: line
       real(kind=cp), dimension(:),  intent(out) :: value
       real(kind=cp), dimension(:),  intent(out) :: std
       integer,                      intent(out) :: ic

    Subroutine Read_Key_Str(Filevar,Nline_Ini,Nline_End,Keyword,String) !Read a string on "filevar" starting with a particular "keyword" between lines "nline_ini" and "nline_end"
       character(len=*),dimension(:), intent(in)      :: Filevar      !  In -> Input vector of strings
       integer,                       intent(in out)  :: Nline_Ini    !  In -> Pointer to initial position to search
                                                                      ! Out -> Pointer to final position in search
       integer,                       intent(in)      :: Nline_End    !  In -> Pointer to final position to search
       character(len=*),              intent(in)      :: Keyword      !  In -> Word to search
       character(len=*),              intent(out)     :: String       ! Out -> Rest of the input string
       character(len=1), optional,    intent(in)      :: comment      !  In -> Character that define a comment line
       
    Subroutine Read_Key_Strval(Filevar,Nline_Ini,Nline_End,Keyword,String,Vet,Ivet,Iv,comment)
       character(len=*),dimension(:),          intent(in)      :: Filevar      !  In -> Input vector of String
       integer,                                intent(in out)  :: Nline_Ini    !  In -> Pointer to initial position to search
                                                                               ! Out -> Pointer to final position in search
       integer,                                intent(in)      :: Nline_End    !  In -> Pointer to final position to search
       character(len=*),                       intent(in)      :: Keyword      !  In -> Word to search
       character(len=*),                       intent(out)     :: String       ! Out -> Rest of the input string
       real(kind=cp),dimension(:),   optional, intent(out)     :: Vet          ! Out -> Vector for real numbers
       integer,dimension(:),         optional  intent(out)     :: Ivet         ! Out -> Vector for integer numbers
       integer,                      optional, intent(out)     :: Iv           ! Out -> Number of numbers
       character(len=1),             optional, intent(in)      :: comment

    Subroutine Read_Key_Value(Filevar,Nline_Ini,Nline_End,Keyword,Vet,Ivet,Iv,comment,line_key)
       character(len=*),dimension(:), intent(in)      :: Filevar     !  In -> Input vector of String
       integer,                       intent(in out)  :: Nline_Ini   !  In -> Pointer to initial position to search
                                                                     ! Out -> Pointer to final position in search
       integer,                       intent(in)      :: Nline_End   !  In -> Pointer to final position to search
       character(len=*),              intent(in)      :: Keyword     !  In -> Word to search
       real(kind=cp),dimension(:),    intent(out)     :: Vet         ! Out -> Vector for real numbers
       integer,dimension(:),          intent(out)     :: Ivet        ! Out -> Vector for integer numbers
       integer,                       intent(out)     :: Iv          ! Out -> Number of components
       character(len=1),     optional, intent(in)     :: comment     ! Consider the character passed in comment as a comment to skip the line
       character(len=*),     optional, intent(out)    :: Iv          ! Out -> Cut line where keyword is read

    Subroutine Read_Key_ValueSTD(Filevar,Nline_Ini,Nline_End,Keyword,Vet1,Vet2,Iv,comment)
       character(len=*),dimension(:),  intent(in)     :: Filevar      !  In -> Input vector of String
       integer,                        intent(in out) :: Nline_Ini    !  In -> Pointer to initial position to search
                                                                      ! Out -> Pointer to final position in search
       integer,                        intent(in)     :: Nline_End    !  In -> Pointer to final position to search
       character(len=*),               intent(in)     :: Keyword      !  In -> Word to search
       real(kind=cp),dimension(:),     intent(out)    :: Vet1         ! Out -> Vector of real numbers
       real(kind=cp),dimension(:),     intent(out)    :: Vet2         ! Out -> Vector of standard deviations
       integer,                        intent(out)    :: Iv           ! Out -> Number of components


       
=============================================
CFML_Diffraction_Patterns: (CFML_Diffpat.f90)       
=============================================

Globals:
--------
    logical,            public :: ERR_Diffpatt=.false.
    character(len=150), public :: ERR_DiffPatt_Mess=" "

Types:
------    
    Type, public :: Diffraction_Pattern_Type
       character(len=180)                          :: Title         !Identification of the pattern
       character(len=20)                           :: diff_kind     !type of radiation
       character(len=20)                           :: scat_var      !x-space: 2theta, TOF, Q, s, d-spacing, SinT/L, Lambda, Energy, Temperature, etc
       character(len=40)                           :: xax_text      !x-axis legend, eg. "Lambda (Angstroms)"
       character(len=40)                           :: yax_text      !y-axis legend, eg. "Intensity (arb. units)"
       character(len=20)                           :: instr         !file type
       character(len=512)                          :: filename      !file name
       character(len=512)                          :: filepath      !file name
       real(kind=cp)                               :: xmin
       real(kind=cp)                               :: xmax
       real(kind=cp)                               :: ymin
       real(kind=cp)                               :: ymax
       real(kind=cp)                               :: scal          
       real(kind=cp)                               :: monitor
       real(kind=cp)                               :: norm_mon      !Normalisation monitor
       real(kind=cp)                               :: col_time      !Data collection time
       real(kind=cp)                               :: step
       real(kind=cp)                               :: Tsamp         !Sample Temperature
       real(kind=cp)                               :: Tset          !Setting Temperature (wished temperature)
       integer                                     :: npts          !Number of points
       logical                                     :: ct_step       !Constant step
       logical                                     :: gy,gycalc,&
                                                      gbgr,gsigma   !logicals for graphics
       logical                                     :: sig_var=.true.!If .true. the content of sigma is in fact the variance
    
       logical                                     :: al_x,al_y,&
                                                      al_ycalc, &   !logicals for allocation
                                                      al_bgr,   &
                                                      al_sigma, &
                                                      al_istat    
       real(kind=cp), dimension (5)                :: conv          ! Wavelengths or Dtt1, Dtt2 for converting to Q,d, etc
       real(kind=cp), dimension (:), allocatable   :: x             ! Scattering variable (2theta...)
       real(kind=cp), dimension (:), allocatable   :: y             ! Experimental intensity
       real(kind=cp), dimension (:), allocatable   :: sigma         ! observations Sigma or variance (the square of sigma!, depends on sig_var)
       integer,       dimension (:), allocatable   :: istat         ! Information about the point "i"
       real(kind=cp), dimension (:), allocatable   :: ycalc         ! Calculated intensity
       real(kind=cp), dimension (:), allocatable   :: bgr           ! Background    
    End Type Diffraction_Pattern_Type
       
==================================== 
CFML_IO_Formats: (CFML_Form_CIF.f90)
==================================== 

Globals:
--------
    logical,            public :: ERR_Form
    character(len=150), public :: ERR_Form_Mess

Types:
------
    Type,public :: File_List_Type
       integer                                       :: nlines
       character(len=256), allocatable, dimension(:) :: line
    End Type File_List_Type

    Type, public :: Job_Info_type
       character(len=120)                            :: Title          ! Title
       integer                                       :: Num_Phases     ! Number of phases
       integer                                       :: Num_Patterns   ! Number of patterns
       integer                                       :: Num_cmd        ! Number of command lines
       character(len=16),  dimension(:), allocatable :: Patt_typ       ! Type of Pattern
       character(len=128), dimension(:), allocatable :: Phas_nam       ! Name of phases
       character(len=128), dimension(:), allocatable :: cmd            ! Command lines: text for actions
       type(interval_type),dimension(:), allocatable :: range_stl      ! Range in sinTheta/Lambda
       type(interval_type),dimension(:), allocatable :: range_q        ! Range in 4pi*sinTheta/Lambda
       type(interval_type),dimension(:), allocatable :: range_d        ! Range in d-spacing
       type(interval_type),dimension(:), allocatable :: range_2theta   ! Range in 2theta-spacing
       type(interval_type),dimension(:), allocatable :: range_Energy   ! Range in Energy
       type(interval_type),dimension(:), allocatable :: range_tof      ! Range in Time of Flight
       type(interval_type),dimension(:), allocatable :: Lambda         ! Lambda
       real(kind=cp)      ,dimension(:), allocatable :: ratio          ! ratio lambda2/lambda1
       real(kind=cp)      ,dimension(:), allocatable :: dtt1,dtt2      ! d-to-TOF coefficients
    End Type Job_Info_type
    

    
Subroutines:
------------ 
    Subroutine File_To_FileList(File_dat,File_list)
      character(len=*),     intent( in) :: file_dat  !Input data file
      type(file_list_type), intent(out) :: file_list !File list structure
  
    The subroutine below constructs the objects: Cell,SpG and A, by reading the file filenam
    It is an overloaded subroutine that may be called using molecular crystals. 
    In this document we use only the split case (Cell,SpG and A) 
    
    Subroutine Readn_Set_Xtal_Structure(filenam,Cell,SpG,A,Mode,Iphase,Job_Type,File_List,CFrame)
       character(len=*),              intent( in)     :: filenam  ! In -> Name of the file
       Type (Crystal_Cell_Type),      intent(out)     :: Cell     ! Out -> Cell object
       Type (Space_Group_Type),       intent(out)     :: SpG      ! Out -> Space Group object
       Type (atom_list_type),         intent(out)     :: A        ! Out -> Atom_List object
       Character(len=*),    optional, intent( in)     :: Mode     ! In -> if Mode="CIF" filenam
                                                                  !       is of CIF type format
       Integer,             optional, intent( in)     :: Iphase   ! Number of the phase.
       Type(Job_Info_type), optional, intent(out)     :: Job_Info ! Diffaction conditions
       Type(file_list_type),optional, intent(in out)  :: file_list! Complete file to be used by
                                                                  ! the calling program or other procedures
       Character(len=*),    optional, intent( in)     :: CFrame   !Cartesian Frame
 
    Subroutine Write_Cif_Template(filename,type_data,code,cell,SpG,A)
       character(len=*),        intent(in) :: filename   !  In -> Filename
       integer,                 intent(in) :: type_data  !  In -> 0: Single Crystal, 1: Powder Data, 2:Only structural data
       character(len=*),        intent(in) :: code       !  In -> Code name for the data set
       Type (Crystal_Cell_Type),intent(in) :: Cell       ! Cell type to be output
       Type (Space_Group_Type), intent(in) :: SpG        ! Space group type to be output
       Type (Atom_List_Type),   intent(in) :: A          ! Atom list type to be output

    Subroutine Write_CFL_Atom_List_Type(lun,Cel,SpG,Atm,comment)
       integer,                  intent(in)    :: lun
       type (Space_Group_Type),  intent(in)    :: SpG
       type (Crystal_Cell_Type), intent(in)    :: Cel
       type (atom_list_type),    intent(in)    :: Atm
       character(len=*),optional,intent(in)    :: comment

    Subroutine Write_Shx_Template(Filename,Code,Title,Lambda,Z,Celda,Space,Atomos)
       character(len=*),        intent(in) :: filename  !  In -> Filename
       integer,                 intent(in) :: code      !  In -> 0 Shelxs-Patterson
                                                                 1 Shelxs-Direct Methods
                                                                 2 Shelxl-Refinement
       character(len=*),        intent(in) :: title     !  In -> Title
       real(kind=cp),           intent(in) :: lambda    !  In -> Lambda
       integer,                 intent(in) :: z         !  In -> Z
       type(Crystal_cell_Type), intent(in) :: celda     !  In -> Cell variable
       type(Space_Group_Type),  intent(in) :: Space     !  In -> SpaceGroup variable
       type(atom_list_type),    intent(in) :: atomos    !  In -> Atom List
    
    Subroutine Write_Cif_Powder_Profile(Filename,Pat,r_facts)
       character(len=*),                    intent(in) :: filename     !  In -> Name of File
       type(Diffraction_Pattern_Type),      intent(in) :: Pat
       real(kind=cp), dimension(4),optional,intent(in) :: r_facts      !R_patt,R_wpatt,R_exp,Chi2

======================================================
CFML_PowderProfiles_Finger: (CFML_Profiles_Finger.f90)
======================================================

Globals:
--------
   None
   
Types:
------
   None
   
Subroutines:
------------
    Subroutine Init_Prof_Val() 
    Subroutine Calc_Pseudo_Voigt(x,y,Twoth0,Eta,Fwhm,asym1,asym2) !Return the calculated ordinates Y(:) corresponding to a normalized Pseudo-Voigt function,
                                                                  !characterized by: Twoth0,Eta,Fwhm,asym1,asym1, for points X(:)
       real(kind=cp), dimension(:), intent(in)   :: x
       real(kind=cp), dimension(:), intent(out)  :: y
       real(kind=cp),               intent(in)   :: Twoth0
       real(kind=cp),               intent(in)   :: eta
       real(kind=cp),               intent(in)   :: Fwhm
       real(kind=cp),               intent(in)   :: asym1        ! s_l source width/detector distance or D_L+S_L if  use_hps is true
       real(kind=cp),               intent(in)   :: asym2        ! d_l detector width/detector distance or D_L-S_L if  use_hps is true
   
    Subroutine Prof_Val(Eta,Gamma,asym1,asym1,Twoth,Twoth0,Dprdt,Dprdg,Dprde,Dprds,Dprdd,Profval,Use_Asym, Use_hps )
       real(kind=cp), intent(in)   :: eta          ! mixing coefficient between Gaussian and Lorentzian
       real(kind=cp), intent(in)   :: gamma        ! FWHM
       real(kind=cp), intent(in)   :: asym1        ! s_l source width/detector distance or D_L+S_L if  use_hps is true
       real(kind=cp), intent(in)   :: asym2        ! d_l detector width/detector distance or D_L-S_L if  use_hps is true
       real(kind=cp), intent(in)   :: twoth        ! point at which to evaluate the profile
       real(kind=cp), intent(in)   :: twoth0       ! two_theta value for peak
       real(kind=cp), intent(out)  :: dprdt        ! derivative of profile wrt TwoTH0
       real(kind=cp), intent(out)  :: dprdg        ! derivative of profile wrt Gamma
       real(kind=cp), intent(out)  :: dprde        ! derivative of profile wrt Eta
       real(kind=cp), intent(out)  :: dprds        ! derivative of profile wrt asym1
       real(kind=cp), intent(out)  :: dprdd        ! derivative of profile wrt asym2
       real(kind=cp), intent(out)  :: profval      ! Value of the profile at point twoth
       logical,       intent(in)   :: use_asym     ! true if asymmetry to be used
       logical,       intent(in)   :: use_hps      ! true if asym1=D_L+S_L and asym2=D_L-S_L
                                                   ! false if asym1=D_L ans asym2=S_L

================================================= 
CFML_PowderProfiles_CW: (CFML_Profile_Functs.f90) 
================================================= 

Globals:
--------
   None
Types:
------
   None
Functions: Par is an array containing the parameters of the function 
----------

    Pure Function Gaussian(X,Par) Result (Gauss_Val)   ! Par(1)=FWHM
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: gauss_val
       
    Pure Function Lorentzian(X,Par) Result (Lor_Val)   ! Par(1)=FWHM
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: lor_val
       
    Pure Function Hat(X,Par) Result (H_Val)            ! Par(1)=FWHM
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: h_val

    Pure Function Pseudovoigt(X,Par) Result (Pv_Val)   !Par = [FWHM, eta]  
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: pv_val
       
    Pure Function TCH_pVoigt(X,Par) Result (Pv_Val)    !Par = [FWHM_G, FWHM_L]
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: pv_val
       
    Pure Function Split_Pseudovoigt(X,Par) Result (Pv_Val)  !Par = [FWHM1,FWHM2,eta1,eta2]
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: pv_val
       
    Pure Function Exponential(X,Par) Result (Ex_Val)   ! Par(1)=alfa, in Ex_Val=alfa*exp(-alfa*x)
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: ex_val
       
    Pure Function Back_To_Back_Exp(X,Par) Result (Bb_Val) !Par = [alfa, beta]
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: bb_val

    Pure Function Ikeda_Carpenter(X,Par) Result (Ik_Val) ! !Par = [alfa, beta, R]
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: ik_val
       
Subroutines:  Calculates the value at the input point X and derivatives w.r.t. parameters
------------

    Pure Subroutine Gaussian_Der(X,Par,Gauss_Val,Dpar)
       real(kind=cp),                       intent(in) :: x
       real(kind=cp),          dimension(:),intent(in) :: par
       real(kind=cp),                       intent(out):: gauss_val
       real(kind=cp), optional,dimension(:),intent(out):: dpar
       
    Pure Subroutine Lorentzian_Der(X,Par,Lor_Val,Dpar)
       real(kind=cp),                        intent(in) :: x
       real(kind=cp),           dimension(:),intent(in) :: par
       real(kind=cp),                        intent(out):: lor_val
       real(kind=cp), optional, dimension(:),intent(out):: dpar
       
    Pure Function Hat(X,Par) Result (H_Val)
       real(kind=cp),              intent(in) :: x
       real(kind=cp), dimension(:),intent(in) :: par
       real(kind=cp)                          :: h_val
       
    Pure Subroutine Pseudovoigt_Der(X,Par,Pv_Val,Dpar)
       real(kind=cp),                       intent(in) :: x
       real(kind=cp), dimension(:),         intent(in) :: par
       real(kind=cp),                       intent(out):: pv_val
       real(kind=cp), optional,dimension(:),intent(out):: dpar
       
    Pure Subroutine TCH_pVoigt_Der(X,Par,Pv_Val,dPar)
       real(kind=cp),                       intent(in) :: x
       real(kind=cp), dimension(:),         intent(in) :: par
       real(kind=cp),                       intent(out):: pv_val
       real(kind=cp), optional,dimension(:),intent(out):: dpar
       
    Pure Subroutine Split_Pseudovoigt_Der(X,Par,Pv_Val,Dpar)
       real(kind=cp),                       intent(in) :: x
       real(kind=cp), dimension(:),         intent(in) :: par
       real(kind=cp),                       intent(out):: pv_val
       real(kind=cp), optional,dimension(:),intent(out):: dpar
       
    Pure Subroutine Exponential_Der(X,Par,Ex_Val,Dpar)
       real(kind=cp),                        intent(in) :: x
       real(kind=cp),           dimension(:),intent(in) :: par
       real(kind=cp),                        intent(out):: ex_val
       real(kind=cp), optional, dimension(:),intent(out):: dpar
       
    Pure Subroutine Back_To_Back_Exp_Der(X,Par,Bb_Val,Dpar)
       real(kind=cp),                        intent(in)  :: x
       real(kind=cp),           dimension(:),intent(in)  :: par
       real(kind=cp),                        intent(out) :: bb_val
       real(kind=cp), optional, dimension(:),intent(out) :: dpar
       
    Pure Subroutine Ikeda_Carpenter_Der(X,Par,Ik_Val,Dpar)
       real(kind=cp),                        intent(in)  :: x
       real(kind=cp),           dimension(:),intent(in)  :: par
       real(kind=cp),                        intent(out) :: ik_val
       real(kind=cp), optional, dimension(:),intent(out) :: dpar

=============================================== 
CFML_PowderProfiles_TOF: (CFML_Profile_TOF.f90) 
=============================================== 
Globals:
--------
   None
Types:
------
    Type, Public :: Deriv_TOF_Type
       real(kind=cp) :: alfa     ! omega_a  DOmega/Dalpha
       real(kind=cp) :: beta     ! omega_b  DOmega/Dbeta
       real(kind=cp) :: dt       ! omega_t  DOmega/Ddt      (dt=TOFi-TOF(Bragg))
       real(kind=cp) :: sigma    ! omega_s  DOmega/Dsigma   (for tof_Jorgensen function)
       real(kind=cp) :: gamma    ! omega_g  DOmega/Dgamma   (for tof_Jorgensen_VonDreele function)
       real(kind=cp) :: eta      ! omega_e  DOmega/Deta                     "
       real(kind=cp) :: kappa    ! omega_e  DOmega/kappa    (for tof_Carpenter function)
    End Type Deriv_TOF_Type

Functions:  
----------
   None
Subroutines:
------------
    
    Subroutine Tof_Jorgensen(Dt,Alfa,Beta,Sigma,Tof_Peak,Deriv)
       real(kind=cp),             intent( in)  :: dt       !  dt = TOF(channel i) -TOF(Bragg position): units microsecs
       real(kind=cp),             intent( in)  :: alfa     !  alfa  : units microsecs-1
       real(kind=cp),             intent( in)  :: beta     !  beta  : units microsecs-1
       real(kind=cp),             intent( in)  :: sigma    !  sigma : units microsecs**2
       real(kind=cp),             intent(out)  :: tof_peak
       type(Deriv_TOF_Type), optional, intent(out)  :: deriv    ! present if derivatives are to be calculated

    Subroutine Tof_Jorgensen_Vondreele(Dt,Alfa,Beta,Gamma,Eta,Tof_Peak,Deriv)
       real(kind=cp),             intent( in) :: dt       ! dt = TOF(channel i) -TOF(Bragg position)
       real(kind=cp),             intent( in) :: alfa     !  alfa  : units microsecs-1
       real(kind=cp),             intent( in) :: beta     !  beta  : units microsecs-1
       real(kind=cp),             intent( in) :: gamma    !  gamma : units microsecs
       real(kind=cp),             intent( in) :: eta      !  eta   : mixing coefficient calculated using TCH
       real(kind=cp),             intent(out) :: tof_peak
       type(Deriv_TOF_Type), optional, intent(out) :: deriv    ! present if derivatives are to be calculated
       
    Subroutine Tof_Carpenter(Dt,D,Alfa,Beta,Gamma,Eta,Kappa,Tof_Theta,Tof_Peak,Deriv)
       real(kind=cp),             intent( in) :: dt        ! dt = TOF(channel i) -TOF(Bragg position)
       real(kind=cp),             intent( in) :: d         ! d-spacing of the peak in A
       real(kind=cp),             intent( in) :: alfa      !  alfa  : units microsecs-1
       real(kind=cp),             intent( in) :: beta      !  beta  : units microsecs-1
       real(kind=cp),             intent( in) :: gamma     !  gamma : units microsecs
       real(kind=cp),             intent( in) :: eta       !  eta   : mixing coefficient calculated using TCH
       real(kind=cp),             intent( in) :: kappa     ! Mixing coeficient of the Ikeda-Carpenter function
       real(kind=cp),             intent( in) :: tof_theta ! This is the value of 2sin(theta)
       real(kind=cp),             intent(out) :: tof_peak
       type(Deriv_TOF_Type), optional, intent(out) :: deriv     ! present if derivatives are to be calculated

=================================================== 
CFML_Reflections_Utilities: (CFML_Reflect_Util.f90)
=================================================== 
Globals:
--------
    logical, public :: ERR_Refl
    character(len=150), public :: ERR_Refl_Mess
Types:
------
    Type, public :: Reflect_Type
       integer,dimension(3) :: H=0     ! H
       integer              :: Mult=0  ! mutiplicity
       real(kind=cp)        :: S=0.0   ! Sin(Theta)/lambda=1/2d
       integer              :: imag=0  !=0 nuclear reflection, 1=magnetic, 2=both
    End Type Reflect_Type
    
    Type, public :: Reflect_List_Type
       integer                                         :: NRef  ! Number of Reflections
       type(reflect_type),allocatable, dimension(:) :: Ref ! Reflection List
    End Type Reflect_List_Type
    
    Type, public :: Reflection_Type
       integer,dimension(3) :: H     ! H
       integer              :: Mult  ! mutiplicity
       real(kind=cp)        :: Fo    ! Observed Structure Factor
       real(kind=cp)        :: Fc    ! Calculated Structure Factor
       real(kind=cp)        :: SFo   ! Sigma of  Fo
       real(kind=cp)        :: S     ! Sin(Theta)/lambda
       real(kind=cp)        :: W     ! Weight
       real(kind=cp)        :: Phase ! Phase in degrees
       real(kind=cp)        :: A     ! real part of the Structure Factor
       real(kind=cp)        :: B     ! Imaginary part of the Structure Factor
       real(kind=cp)        :: AA    ! Free
       real(kind=cp)        :: BB    ! Free
    End Type Reflection_Type
    
    Type, public :: Reflection_List_Type
       integer                                         :: NRef  ! Number of Reflections
       type(reflection_type),allocatable, dimension(:) :: Ref ! Reflection List
    End Type Reflection_List_Type
    
Functions:  
----------
    Function Get_MaxNumRef(SinTLMax, VolCell, SinTLMin, Mult) Result(numref)
       real(kind=cp),           intent(in) :: SinTLMax
       real(kind=cp),           intent(in) :: VolCell
       real(kind=cp), optional, intent(in) :: SinTLMin
       integer,       optional, intent(in) :: Mult
       integer                             :: numref
       
Subroutines:
------------
    !Overloaded Hkl_Equiv_List: Calculates the multiplicity of the reflection and the list of all
    !                           equivalent reflections. Friedel law assumed if Friedel=.true.
    Subroutine Hkl_Equiv_List(H,Spacegroup,Friedel,Mul,Hlist)
       !---- Arguments ----!
       integer or real, dimension(3),             intent (in) :: h
       Type (Space_Group_Type),                   intent (in) :: SpaceGroup
       Logical,                                   intent (in) :: Friedel
       integer,                                   intent(out) :: mul
       integer, dimension(3,SpaceGroup%numops*2), intent(out) :: hlist
       
    Subroutine  Hkl_Gen(Crystalcell,Spacegroup,Friedel,Value1,Value2,Num_Ref,Reflex) !Generates non-ordered reflections of Reflect_type
       Type (Crystal_Cell_Type),          intent(in) :: CrystalCell     !Unit cell object
       Type (Space_Group_Type) ,          intent(in) :: SpaceGroup      !Space Group object
       Logical,                           intent(in) :: Friedel         !If true, Friedel law applied
       real(kind=cp),                     intent(in) :: value1,value2   !Range in SinTheta/Lambda
       Integer,                           intent(out):: Num_Ref         !Number of generated reflections
       Type (Reflect_Type), dimension(:), intent(out):: Reflex          !List of generated hkl,mult, s
       
    Subroutine  Hkl_GenShub(Crystalcell,Spacegroup,ShubG,sintlmax,Num_Ref,Reflex) !Generates non-ordered reflections for a Shubnikov group
       Type (Crystal_Cell_Type),          intent(in) :: CrystalCell     !Unit cell object
       Type (Magnetic_Space_Group_Type) , intent(in) :: ShubG           !Magnetic Space Group object
       real(kind=cp),                     intent(in) :: sintlmax        !Maximum SinTheta/Lambda
       Integer,                           intent(out):: Num_Ref         !Number of generated reflections
       Type (Reflect_Type), dimension(:), intent(out):: Reflex          !List of generated hkl,mult, s
       
    !Overloaded  HKL_UNI (Hkl_Uni_Reflect,Hkl_Uni_Reflection,Hkl_Uni_ReflList)
    Subroutine  Hkl_Uni(Crystalcell, Spacegroup,Friedel,Value1,Value2,Code,Num_Ref,Reflex,no_order,check_ok)
       Type (Crystal_Cell_Type),          intent(in) :: CrystalCell  !Cell Objet
       Type (Space_Group_Type) ,          intent(in) :: SpaceGroup   !Space group Object
       Logical,                           intent(in) :: Friedel
       real(kind=cp),                     intent(in) :: value1,value2 !Range in sintheta/Lambda
       character(len=1),                  intent(in) :: code     !If code="r", d-spacing are input as value1,value2
       Integer,                           intent(out):: num_Ref  !Number of generated reflections
       Type (Reflect_Type), dimension(:), intent(out):: reflex   !Ordered set of reflections
       !or
       !Type (Reflection_Type), dimension(:), intent(out):: reflex   !Ordered set of reflections
       !or
       !Type (Reflection_List_Type), dimension(:), intent(out):: reflex   !Ordered set of reflections
       logical,                optional,  intent(in) :: no_order !Not ordered id no_order=.true. is present
       logical,                optional,  intent(out):: check_ok !Check if the maximum number of reflections has been attained
    
    !Overloaded  HKL_GEN_SXTAL (Hkl_Gen_Sxtal_List, Hkl_Gen_Sxtal_Reflection)
    Subroutine  Hkl_Gen_Sxtal (Crystalcell,Spacegroup,stlmin,stlmax,Num_Ref,Reflex,ord,hlim) !Generates reflections
       Type (Crystal_Cell_Type),          intent(in) :: CrystalCell     !Unit cell object
       Type (Space_Group_Type) ,          intent(in) :: SpaceGroup      !Space Group object
       real(kind=cp),                     intent(in) :: stlmin,stlmax   !Minimum and Maximum SinTheta/Lambda
       Integer,                           intent(out):: Num_Ref         !Number of generated reflections
       Type (Reflect_Type), dimension(:), intent(out):: Reflex          !List of generated hkl,mult, s
       !or
       !Type (Reflection_List_Type),       intent(out):: Reflex          !List of generated hkl,mult, s and structure factors
       Integer, dimension(3),   optional, intent(in) :: ord             !Order for loop of hkl-indices
       Integer, dimension(3,2), optional, intent(in) :: hlim            !hkl-limits
       
    Subroutine Integral_Conditions(Spacegroup,iunit)  !Writes in logical unit "iunit" the presence conditions of reflections for Spacegroup
       type (Space_Group_Type),  intent(in)     :: spacegroup
       integer, optional,        intent(in)     :: iunit
       
    Subroutine Write_RefList_Info(Rfl, Iunit, Mode) !Writes in logical unit "iunit" the list of reflections Rfl
       !---- Arguments ----!
       type (Reflection_List_Type), intent(in) :: Rfl
       integer,optional,            intent(in) :: iunit
       character(len=*), optional,  intent(in) :: Mode

       
============================================ 
CFML_Propagation_Vectors: (CFML_Propagk.f90)
============================================ 
Globals:
--------
   None
Types:
------
    Type, Public :: Group_K_Type
       type(Space_Group_Type)        :: G0             !Initial space group
       integer                       :: ngk            !Number of elements of G_k
       logical                       :: k_equiv_minusk !true if k equiv -k
       logical                       :: minusk         !true if there is at least one operator transforming k into -k (even if there's no inversion centre)
       integer,      dimension(192)  :: p              !Pointer to operations of G0 that changes/fix k
                                                       !First indices: G_k, last indices: Stark
       integer, dimension(48,48)     :: co             !Pointers of symmetry operators of G0 constituting the
                                                       !coset representatives of a particular k-vector of the star
                                                       !Only the nk x nk submatrix is used, the rest is zero.
       integer                       :: nk             !Number of star arms
       real(kind=cp),dimension(3,48) :: stark          !Star of the wave vector k
    End Type Group_K_Type

Functions:  
----------
    Function Hk_Equiv(H,K,Spacegk,Friedel) Result (Info) !Calculates if two real reflections are equivalent
       real(kind=cp), dimension(3), intent (in) :: h,k
       Type (Group_k_Type),         intent (in) :: SpaceGk
       logical, optional,           intent(in)  :: Friedel
       logical                                  :: info
       
    Function K_Equiv(H,K,Latyp) Result (Info)   !Calculates if two k-vectors are equivalent: H-K is a reciprocal lattice vector
       real(kind=cp), dimension(3),intent (in) :: h,k
       character (len=*),          intent (in) :: latyp
       logical                                 :: info

    Function K_Equiv_Minus_K(Vec,Lat) result(equiv) !Determines if K is equivalent to -K
       real(kind=cp), dimension(3), intent(in) :: vec
       character(len=*),            intent(in) :: Lat
       logical                                 :: equiv
       
Subroutines:
------------
    
    Subroutine K_Star(K,Spacegroup,Gk,ext) !Determines the star of the little group (or the extended little group if ext=.true.)
       real(kind=cp), dimension(3), intent (in) :: k
       Type (Space_Group_Type),     intent (in) :: SpaceGroup
       Type (Group_k_Type),         intent(out) :: Gk
       logical, optional,           intent(in)  :: ext
       
    Subroutine Set_Gk(Gk,SPGk,ext) !converts  Gk, or Gk,-k, to a conventional space group.
       Type (Group_k_Type),     intent(in)  :: Gk
       Type (Space_Group_Type), intent(out) :: SPGk
       logical, optional,       intent(in)  :: ext
       
    Subroutine Write_Group_k(Gk,lun) !Writes the operators of Gk and the star {k}
       Type (Group_k_Type),   intent(in) :: Gk
       Integer, optional,     intent(in) :: lun
       
==========================================
CFML_Magnetic_Symmetry: (CFML_magSymm.f90)
==========================================

Globals:
--------
    logical,            public :: ERR_MagSym
    character(len=150), public :: ERR_MagSym_Mess
    
Types:
------
    Type, Public :: MagSymm_k_Type
       character(len=31)                        :: MagModel   ! Name to characterize the magnetic symmetry
       character(len=10)                        :: Sk_type    ! If Sk_type="Spherical_Frame" the input Fourier coefficients are in spherical components
       character(len=15)                        :: BNS_number ! Added for keeping the same information
       character(len=15)                        :: OG_number  ! as in Magnetic_Space_Group_Type
       Character(len=34)                        :: BNS_symbol !             "
       Character(len=34)                        :: OG_symbol  !             "
       Integer                                  :: MagType    !             "
       Integer                                  :: Parent_num !             "
       Character(len=20)                        :: Parent_spg !             "
       character(len=1)                         :: Latt       ! Symbol of the crystallographic lattice
       integer                                  :: nirreps    ! Number of irreducible representations (max=4, if nirreps /= 0 => nmsym=0)
       Integer,             dimension(4)        :: irrep_dim       !Dimension of the irreps
       Integer,             dimension(4)        :: small_irrep_dim !Dimension of the small irrep
       Integer,             dimension(4)        :: irrep_modes_number !Number of the mode of the irrep
       Character(len=15),   dimension(4)        :: irrep_id        !Labels for the irreps
       Character(len=20),   dimension(4)        :: irrep_direction !Irrep direction in representation space
       Character(len=20),   dimension(4)        :: irrep_action    !Irrep character primary or secondary
       integer                                  :: nmsym      ! Number of magnetic operators per crystallographic operator (max=8)
       integer                                  :: centred    ! =0 centric centre not at origin, =1 acentric, =2 centric (-1 at origin)
       integer                                  :: mcentred   ! =1 Anti/a-centric Magnetic symmetry, = 2 centric magnetic symmetry
       integer                                  :: nkv        ! Number of independent propagation vectors
       real(kind=cp),       dimension(3,12)     :: kvec       ! Propagation vectors
       Character(len=15),   dimension(12)       :: kv_label
       integer                                  :: Num_Lat    ! Number of centring lattice vectors
       real(kind=cp), dimension(3,4)            :: Ltr        ! Centring translations
       integer                                  :: Numops     ! Reduced number of crystallographic Symm. Op.
       integer                                  :: Multip     ! General multiplicity of the space group
       integer,             dimension(4)        :: nbas       ! Number of basis functions per irrep (if nbas < 0, the corresponding basis is complex).
       integer,             dimension(12,4)     :: icomp      ! Indicator (0 pure real/ 1 pure imaginary) for coefficients of basis fucntions
       Complex(kind=cp),    dimension(3,12,48,4):: basf       ! Basis functions of the irreps of Gk
       character(len=40),   dimension(:),   allocatable :: SymopSymb  ! Alphanumeric Symbols for SYMM
       type(Sym_Oper_Type), dimension(:),   allocatable :: SymOp      ! Crystallographic symmetry operators (48)
       character(len=40),   dimension(:,:), allocatable :: MSymopSymb ! Alphanumeric Symbols for MSYMM (48,8)
       type(MSym_Oper_Type),dimension(:,:), allocatable :: MSymOp     ! Magnetic symmetry operators (48,8)
    End Type MagSymm_k_Type
    
    Type, public :: Magnetic_Domain_type
       integer                           :: nd=0          !Number of rotational domains (not counting chiral domains)
       logical                           :: Chir=.false.  !True if chirality domains exist
       logical                           :: trans=.false. !True if translations are associated to matrix domains
       logical                           :: Twin=.false.  !True if domains are to be interpreted as twins
       integer,dimension(3,3,24)         :: DMat=0        !Domain matrices to be applied to Fourier Coefficients
       real(kind=cp), dimension (2,24)   :: Dt=0.0        !Translations associated to rotation matrices
       real(kind=cp), dimension (2,24)   :: pop=0.0       !Populations of domains (sum=1,
                                                          !the second value is /=0 for chir=.true.)
       real(kind=cp), dimension (2,24)   :: pop_std=0.0   !Standard deviations of Populations of domains
       integer,dimension (2,24)          :: Lpop=0        !Number of the refined parameter
       real(kind=cp), dimension (2,24)   :: Mpop=0.0      !Refinement codes for populations
       character(len=10),dimension (2,24):: Lab           !Label of domain
    End type Magnetic_Domain_type

Functions:  
----------
    None
    
Subroutines:
------------
    Subroutine Readn_Set_Magnetic_Space_Group(file_line,n_ini,n_end,MGp,mode,uvw) !Generates MGp
       character(len=*),dimension(:),  intent (in)  :: file_line
       integer,                        intent (in)  :: n_ini,n_end
       type(Magnetic_Space_Group_Type),intent (out) :: MGp
       character(len=*),               intent (in)  :: mode ! "Database","PCR","CFL"
                                                            !In the last case the directive is like SHUBNIKOV Pnm'a  setting: c,a,b;0,0,0  
                                                            !for Pbnm')
       character(len=*), optional,     intent (in)  :: uvw  ! if present and uvw="mxmymz" this notation instead of u,v,w is used for operator symbols
       
    Subroutine Set_Magnetic_Space_Group(symb,setting,MSpg,parent,mcif,keepd,trn_to)
       character (len=*),                intent(in) :: symb        !  In -> String with the BNS symbol of the Shubnikov Group
       character (len=*),                intent(in ):: setting     !  In -> setting in the form -a,c,2b;1/2,0,0 (if empty no transformation is performed)
       Type (Magnetic_Space_Group_Type), intent(out):: MGp         ! Out -> Magnetic Space Group object
       character (len=*), optional,      intent(in ):: Parent      !  In -> Parent crystallographic group
       logical,  optional,               intent(in ):: mcif        !  In -> True if one wants to store the symbols as mx,my,mz
       logical,  optional,               intent(in ):: keepd       !  In -> True if one wants to keep the database allocated
       logical,  optional,               intent(in ):: trn_to      !  In -> True if the setting is from current TO standard setting
    
    !Overloaded  Readn_Set_Magnetic_Structure: (Readn_Set_Magnetic_Structure_CFL,Readn_Set_Magnetic_Structure_MCIF)  
    Subroutine Readn_Set_Magnetic_Structure_CFL(file_cfl,n_ini,n_end,MGp,Am,SGo,Mag_dom,Cell) !Magnetic structure using MagSymm_k_Type
       type(file_list_type),                intent (in)     :: file_cfl
       integer,                             intent (in out) :: n_ini, n_end
       type(MagSymm_k_Type),                intent (out)    :: MGp
       type(mAtom_List_Type),               intent (out)    :: Am
       type(Magnetic_Group_Type), optional, intent (out)    :: SGo
       type(Magnetic_Domain_type),optional, intent (out)    :: Mag_dom
       type(Crystal_Cell_type),   optional, intent (in)     :: Cell
       
    Subroutine Readn_Set_Magnetic_Structure_MCIF(file_mcif,mCell,MGp,Am) !Reads an mCIF file for constructing a magnetic structure
       character(len=*),               intent (in)  :: file_mcif         !as described by Shubnikov groups
       type(Crystal_Cell_type),        intent (out) :: mCell
       type(Magnetic_Space_Group_Type),intent (out) :: MGp
       type(mAtom_List_Type),          intent (out) :: Am
       
    Subroutine Get_moment_ctr(xnr,moment,Spg,codini,codes,ord,ss,att,Ipr) !Get constraints in the magnetic moment of the atom in position xnr
       real(kind=cp), dimension(3),            intent(in)     :: xnr     !Position of the atom
       real(kind=cp), dimension(:),            intent(in out) :: moment  !Magnetic moment
       real(kind=cp), dimension(:),            intent(in out) :: codes   !Codes as in FullProf
       type(Magnetic_Space_Group_type),        intent(in)     :: Spg
       Integer,                                intent(in out) :: codini  !First code number
       integer,                       optional,intent(in)     :: ord
       integer, dimension(:),         optional,intent(in)     :: ss
       real(kind=cp), dimension(:,:), optional,intent(in)     :: att
       integer,                       optional,intent(in)     :: Ipr

    Subroutine Write_Magnetic_Structure(Ipr,MGp,Am,Mag_Dom,cell) !Writes a magnetic structure using MagSymm_k_Type to file associated to unit=Ipr 
       !---- Arguments ----!
       Integer,                    intent(in)           :: Ipr
       type(MagSymm_k_Type),       intent(in)           :: MGp
       type(mAtom_List_Type),      intent(in)           :: Am
       type(Magnetic_Domain_Type), intent(in), optional :: Mag_Dom
       type(Crystal_Cell_type),    intent(in), optional :: cell

    Subroutine Write_MCIF(Ipr,mCell,MSGp,Am,Cell) !Writes a magnetic mCIF file associated associated to unit=Ipr 
       Integer,                         intent(in)      :: Ipr
       type(Magnetic_Space_Group_Type), intent(in)      :: MSGp
       type(Crystal_Cell_Type),         intent(in)      :: mCell
       type(mAtom_List_Type),           intent(in)      :: Am
       type(Crystal_Cell_Type),optional,intent(in)      :: Cell

=======================================
CFML_Structure_Factors: (CFML_Sfac.f90)
=======================================

Globals:
--------
    logical, public :: ERR_SFac
    character(len=150), public :: ERR_SFac_Mess
    
Types:
------
    Type, public :: Scattering_Species_Type
       integer                                        :: Num_Species
       character(len=6),    dimension(:), allocatable :: Symb
       real(kind=cp),       dimension(:), allocatable :: br,bi
       real(kind=cp),       dimension(:), allocatable :: delta_fp,delta_fpp
       type(Xray_Form_Type),dimension(:), allocatable :: Xcoef
    End Type Scattering_Species_Type

Functions:
----------
    None
    
Subroutines:
------------
   Subroutine Additional_Scattering_Factors(fil,add_Scatt,ok,mess) !Reads additional scattering factors replacing those
      Type(File_List_Type),          intent(in)  :: fil            !read from database CFML_Scattering_Chemical_Tables
      Type(Scattering_Species_Type), intent(out) :: add_Scatt
      logical,                       intent(out) :: ok
      character(len=*),              intent(out) :: mess
      
    Subroutine Init_Structure_Factors(Reflex,Atm,Grp,Mode,lambda,lun) !Allocates and initializes arrays for Structure Factors calculations.
       type(reflection_list_type),          intent(in) :: Reflex      !A calculation of fixed tables is also performed.
       type(atom_list_type),                intent(in) :: Atm         !List of atoms
       type(space_group_type),              intent(in) :: Grp         !Space group
       character(len=*),          optional, intent(in) :: Mode        !"NUC","ELE" for neutrons, electrons else: XRays
       real(kind=cp),             optional, intent(in) :: lambda      !Needed for Xrays
       integer,                   optional, intent(in) :: lun         !Logical unit for writing scattering factors           
       
    Subroutine Structure_Factors(Atm,Grp,Reflex,Mode,lambda) !Calculates structure factors of the list Reflex
       type(atom_list_type),               intent(in)     :: Atm    !List of atoms
       type(space_group_type),             intent(in)     :: Grp    !Space group
       type(reflection_list_type),         intent(in out) :: Reflex !It is completed on output
       character(len=*), optional,         intent(in)     :: Mode   !"NUC","ELE" for neutrons, electrons else: XRays
       real(kind=cp), optional,            intent(in)     :: lambda !Needed for Xrays
       
    Subroutine Calc_StrFactor(mode,rad,nn,sn,Atm,Grp,sf2,deriv,fc) !Calculate Structure Factor and derivatives for reflection "nn" in the list
       character(len=*),                   intent(in) :: mode  !S-XTAL (S) or Powder (P)
       character(len=*),                   intent(in) :: rad   !Radiation: X-rays, Neutrons
       integer,                            intent(in) :: nn    !Number of reflection in the list Reflex used in Init_Structure_Factors
       real(kind=cp)                       intent(in) :: sn    !(sinTheta/Lambda)**2
       type(atom_list_type),               intent(in) :: Atm   !List of atoms
       type(space_group_type),             intent(in) :: Grp   !Space Group
       real(kind=cp)                       intent(out):: sf2   !Structure factor squared
       real(kind=cp),dimension(:),optional,intent(out):: deriv !Derivatives w.r.t. free parameters
       complex, optional,                  intent(out):: fc    !Structure factor amplitude
       
    Subroutine Write_Structure_Factors(lun,Reflex,Mode) !Writes the list of structure factors
       !---- Argument ----!
       integer,                            intent(in) :: lun
       type(reflection_list_type),         intent(in) :: Reflex
       Character(len=*), optional,         intent(in) :: Mode

=================================================
CFML_Magnetic_Structure_Factors: (CFML_Msfac.f90)
=================================================

Globals:
--------
    logical,            public :: ERR_msfac
    character(len=150), public :: ERR_msfac_Mess
    
Types:
------
    Type, Public  :: MagH_Type
       logical                          :: keqv_minus  !True if k equivalent to -k
       integer                          :: mult        !Multiplicity of the reflection (useful for powder calculations)
       integer                          :: num_k       !number of the propagation vector vk
       real(kind=cp)                    :: signp       !+1 for -vk   and -1 for +vk
       real(kind=cp)                    :: s           !sinTheta/Lambda
       real(kind=cp)                    :: sqMiV       !Square of the Magnetic Interaction vector
       real(kind=cp),    dimension(3)   :: H           ! H +/- k
       complex(kind=cp), dimension(3)   :: MsF         !Magnetic structure factor w.r.t. unitary Crystal Frame
       complex(kind=cp), dimension(3,3) :: TMsF        !tensorial magnetic structure factor
       complex(kind=cp), dimension(3)   :: MiV         !Magnetic interaction vector w.r.t. unitary Crystal Frame
       complex(kind=cp), dimension(3)   :: MiVC        !Magnetic interaction vector in Cartesian components w.r.t. Crystal Frame
    End Type  MagH_Type
    
    Type, Public  :: MagH_List_Type
       integer                                   :: Nref
       Type(MagH_Type),allocatable, dimension(:) :: Mh
    End Type MagH_List_Type
    
    Type, Public  :: MagHD_Type
       logical                            :: keqv_minus
       integer                            :: num_k     !number of the propagation vector vk
       real(kind=cp)                      :: signp     !+1 for -vk   and -1 for +vk
       real(kind=cp)                      :: s         !sinTheta/Lambda
       real(kind=cp)                      :: sqAMiV    !Square of the Average Magnetic Interaction vector
       real(kind=cp)                      :: sqMiV     !Average of the Square of Magnetic Interaction vectors
       real(kind=cp),   dimension(3)      :: H         ! H +/- k
       complex(kind=cp),dimension(3,2,24) :: MsF       !Magnetic structure factors of each domain (second dimension for chirality domains)
       complex(kind=cp),dimension(3,2,24) :: MiV       !Magnetic interaction vector of each domain
       complex(kind=cp),dimension(3,2,24) :: MiVC      !Magnetic interaction vector of each domain in Cartesian Crystal space
       complex(kind=cp),dimension(3)      :: AMiV      !Average Magnetic interaction vector = 1/nd Sum{ pop(i) Miv(:,i)}
    End Type  MagHD_Type
    
    Type, Public  :: MagHD_List_Type
       integer                                    :: Nref
       Type(MagHD_Type),allocatable, dimension(:) :: Mh
    End Type MagHD_List_Type

Functions:
----------
    None
    
Subroutines:
------------
    Subroutine Gen_Satellites(Cell,Grp,Smax,H,Ord,Powder,hkl)
       type(Crystal_Cell_type),               intent(in)     :: cell
       type(MagSymm_k_Type),                  intent(in)     :: Grp
       real(kind=cp),                         intent(in)     :: smax
       type(MagH_List_Type),                  intent(in out) :: H
       logical, optional,                     intent(in)     :: ord
       logical, optional,                     intent(in)     :: powder
       type (Reflection_List_Type), optional, intent(in)     :: hkl
       
    Subroutine Get_mOrbit(x,Spg,Mult,orb,ptr)
       real(kind=cp), dimension(3),    intent (in) :: x
       type(Magnetic_Space_Group_type),intent (in) :: spg
       integer,                        intent(out) :: mult
       real(kind=cp),dimension(:,:),   intent(out) :: orb
       integer,dimension(:),optional,  intent(out) :: ptr
       
    Subroutine Get_mOrbit_mom(x,mom,Spg,Mult,orb,morb,ptr)
       !---- Arguments ----!
       real(kind=cp), dimension(3),    intent (in) :: x,mom
       type(Magnetic_Space_Group_type),intent (in) :: spg
       integer,                        intent(out) :: mult
       real(kind=cp),dimension(:,:),   intent(out) :: orb,morb
       integer,dimension(:),optional,  intent(out) :: ptr

    Subroutine Init_Mag_Structure_Factors(Reflex,Atm,Grp,lun)
       type(MagH_List_Type),           intent(in) :: Reflex
       type(Matom_list_type),          intent(in) :: Atm
       type(MagSymm_k_Type),           intent(in) :: Grp
       integer,              optional, intent(in) :: lun
       
    Subroutine Mag_Structure_Factors(Cell,Atm,Grp,Reflex)
       type(Crystal_Cell_type),  intent(in)     :: Cell
       type(Matom_list_type),    intent(in)     :: Atm
       type(MagSymm_k_Type),     intent(in)     :: Grp
       type(MagH_List_Type),     intent(in out) :: Reflex

    Subroutine Calc_Magnetic_Strf_Miv(Cell,Mgp,Atm,Mh)
       type(Crystal_Cell_type),  intent(in)     :: Cell
       type(MagSymm_k_Type),     intent(in)     :: MGp
       type(Matom_list_type),    intent(in)     :: Atm
       type(MagH_Type),          intent(in out) :: Mh
       
    Subroutine Calc_Magnetic_Strf_Miv_Dom(Cell,Mgp,Atm,Mag_Dom,Mh)
      type(Crystal_Cell_type),   intent(in)      :: Cell
       type(MagSymm_k_Type),      intent(in)      :: MGp
       type(Matom_list_type),     intent(in)      :: Atm
       type(Magnetic_Domain_type),intent(in)      :: Mag_Dom
       type(MagHD_Type),          intent(in out)  :: Mh

    Subroutine Calc_Magnetic_Strf_Tensor(SpG,Atm,Mh)
       type(Space_Group_Type),   intent(in)     :: SpG
       type(Matom_list_type),    intent(in)     :: Atm
       type(MagH_Type),          intent(in out) :: Mh
       
    Subroutine Write_Mag_Structure_Factors(Lun,Reflex,Grp)
       integer,               intent(in) :: lun
       type(MagH_List_Type),  intent(in) :: Reflex
       type(MagSymm_k_Type),  intent(in) :: Grp
