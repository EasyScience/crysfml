C -------------------------------------------------------------
C *****ABSORB VERSION 5.1 STARTED APRIL 2002 RJA
C
C THIS FILE HAS THE SUBROUTINES TO SET UP THE MODEL CRYSTAL
C 
C *****************************************************************
C BASED IN PART UPON ABSORB (BURNHAM, 1966; MODIFIED BY LW FINGER)*
C *****************************************************************
C
C
C VERSION 5.2:
C
C RETURN TO ABSORB4.0 STYLE SO AS TO HANDLE HKL INPUT AS WELL AS XYZ
C  ALSO MEANS THAT FACE DATA READ FROM FACE_STORE 

	SUBROUTINE GETFACES
C
	INCLUDE 'crystalmodel.inc'
	INCLUDE 'Files.inc'
	INCLUDE 'Flags.inc'
	INCLUDE 'UNITCELL.INC'
	INCLUDE 'DAC.INC'

	REAL XSUM(3),C(3)
	INTEGER TEDGE(200,40),NTEMP(200)
	CHARACTER*3 FLAG, ETEXT*256
C
C READ THE FACE INFO FROM THE FACE_STORE
C
	IF(IMODELFORM .EQ. 1)CALL READ_HKL
	IF(IMODELFORM .EQ. 2)CALL READ_XYZ_FACE
	IF(IMODELFORM .EQ. 3)CALL READ_XYZ_CORNER
	IF(IFATAL .EQ. 1)RETURN

C
C TEST FOR FACES: NEED MINIMUM OF 4
C
	IF(I1 .LT. 4)THEN
		CALL WRITE_CRYSTAL_DATA(IPRT)
		WRITE(ETEXT,1)I1
1	FORMAT('ONLY ',I1,' FACES FOUND FOR CRYSTAL: NEED 4 AS MINIMUM')
	CALL ERROR(ETEXT)
	RETURN
	ENDIF
C
C NOW SET APPROPRIATE SIGNS IN FACE EQUATIONS AND PRINT
C
c 
C
	IF(ISMALL .EQ. 0)WRITE(iprt,122)
122	FORMAT(//5X,' EQUATIONS OF CRYSTAL FACES IN ',
	1			' BUSING-LEVY PHI-AXIS SYSTEM:'/)
C
C
	IF(IXANVIL .GT. 0 .AND. ISMALL .EQ. 0)WRITE(IPRT,121)
121	FORMAT(5X,' THESE INCLUDE FACES GENERATED FROM',
	1			' INFO ON DAC CRYSTAL CARD'/)

	DO I=1,I1
	  SUM=0.
	  DO J=1,3
	    SUM=SUM+B(I,J)*XORI(J)			!XORI IS COORDS OF A POINT INSIDE CRYSTAL
	  ENDDO
	  IF(SUM+B(I,4) .LT. 0.0)THEN
	    DO J=1,4
	      B(I,J)=-1.0*B(I,J)
	    ENDDO
	  ENDIF
	  IF(ISMALL .EQ. 0)WRITE(IPRT,123)I,(B(I,J),J=1,4)
123	  FORMAT(4X,I2,':  (',F11.6,')X + (',F11.6,')Y + (',F11.6,
     1    ')Z + (',F11.6,') = 0')
		DO J=1,4
			B(I,J)=B(I,J)*100.		!BETTER CONDITIONING FOR INVERSION
		ENDDO
	ENDDO
C
C BACK-CONVERT FACES INTO HKL, D
C
	IF(IUB .NE. 0)THEN
		CALL XYZ_TO_HKL
		IF(ISMALL .EQ. 0)THEN
		WRITE(iprt,125)
125		FORMAT(//5X,' EQUATIONS OF CRYSTAL FACES AS HKL AND DISTANCE:'/
	1	15x,'H',9X,'K',9X,'L',5X,'DISTANCE (MM)')
		DO I=1,I1
			write(iprt,126)i,(hkld(i,j),j=1,4)
126			format(4x,i2,':  ',4f10.5)
		ENDDO
		ENDIF
	endif
C
C BACK CALCULATE COORDINATES OF CORNERS IN DAC COORDINATES
C BY LOOPING OVER ALL POSSIBLE COMBINATIONS OF THREE PLANES
C AND TESTING INTERSECTION FOR BEING ON SURFACE OF CRYSTAL
C
	IF(ISMALL .EQ. 0)WRITE(IPRT,200)
 200	FORMAT(//5X,'CORNERS OF CRYSTAL FOUND BY CALCULATION')
	IF(IMODELORIGIN .EQ. 1)THEN
			WRITE(IPRT,201)MODEL_ORIGIN
201			FORMAT(5X,'NOTE THAT ORIGIN SHIFTED AT USER REQUEST BY ',3F12.2)
	ENDIF		
C
	IF(ISMALL .EQ. 0)WRITE(IPRT,203)
203	FORMAT(//5X,'FACES',15X,'COORDINATES OF INTERSECTION'/)
	NCORN=0
C
	DO I=1,I1-2
	  DO J=I+1,I1-1
	    DO K=J+1,I1
		CALL GETCORNER(I,J,K,C,IFND)
		IF(IFND .EQ. 0)GOTO230
C
C VECTOR C NOW HOLDS POSITION OF INTERSECTION OF THREE PLANES
C - NOW DETERMINE IF IT IS ON THE CRYSTAL SURFACE
C
		IF(INCRYSTAL(C) .EQ. 0)THEN
C 
C CHECK FOR A NEW CORNER
C
		  FLAG='NEW'
		  DO L=1,NCORN
		    ISAME=0
		    DO M=1,3
			IF(ABS(CORNER(L,M)-C(M)) .LT. 1.0E-3)ISAME=ISAME+1
		    ENDDO
		    IF(ISAME .EQ. 3)THEN
			FLAG='OLD'
			IC=L
		    ENDIF
		  ENDDO
		  IF(ISMALL .EQ. 0)WRITE(IPRT,220)I,J,K,C,FLAG
220		  FORMAT(3I4,3F13.3,5X,A3)
C
C FOR NEW CORNER STORE CORNER COORDS 
C
		  IF(FLAG .EQ. 'NEW')THEN
		    NCORN=NCORN+1
		    IF(NCORN .GT. 200)THEN
			  CALL WRITE_CRYSTAL_DATA(IPRT)
		      write(ETEXT,225)
225		      FORMAT('MORE THAN 200 CORNERS ON CRYSTAL MODEL',
	1			': 200 IS THE MAX ALLOWED')
		      CALL ERROR(ETEXT)
			  RETURN
		    ENDIF
		    DO L=1,3
			XSUM(L)=XSUM(L)+C(L)
		  	CORNER(NCORN,L)=C(L)
		    ENDDO
C
C STORE INDECES FOR LATER EDGE SEARCH
C
		    TEDGE(NCORN,1)=I
		    TEDGE(NCORN,2)=J
		    TEDGE(NCORN,3)=K
		    NTEMP(NCORN)=3
		  ELSE
C
C OLD CORNER: CHECK FOR NEW PLANES AT CORNER
C
		    MF=NTEMP(IC)
		    DO M=1,MF
			IF(I .EQ. TEDGE(IC,M))GOTO226
		    ENDDO
		    NTEMP(IC)=NTEMP(IC)+1
		    TEDGE(IC,NTEMP(IC))=I
226		    DO M=1,MF
			IF(J .EQ. TEDGE(IC,M))GOTO227
		    ENDDO
		    NTEMP(IC)=NTEMP(IC)+1
		    TEDGE(IC,NTEMP(IC))=J
227		    DO M=1,MF
			IF(K .EQ. TEDGE(IC,M))GOTO228
		    ENDDO
		    NTEMP(IC)=NTEMP(IC)+1
		    TEDGE(IC,NTEMP(IC))=K
228		  ENDIF	
		ENDIF
230	    ENDDO
	  ENDDO
	ENDDO
	IF(NCORN .EQ. 0)THEN
		CALL WRITE_CRYSTAL_DATA(IPRT)
	  write(ETEXT,240)
240	  FORMAT('NO CORNERS FOUND ON CRYSTAL MODEL')
	  CALL ERROR(ETEXT)
		RETURN
	ENDIF
C
C GET GRID ORIGIN FROM PROPER AVERAGE OF ALL UNIQUE CORNERS
C  moved this to before call to getedges to allow printing of grid origin 12 April 2012
c
	DO I=1,3
	  XORI(I)=XSUM(I)/NCORN
	ENDDO
	IF(ISMALL .EQ. 0)THEN
		WRITE(IPRT,245)XORI
245		FORMAT(/,12X,'BARYCENTRE OF CRYSTAL (AVERAGE OF ALL CORNERS):'
	1	/12X,3F13.3)
	ELSE
		WRITE(IPRT,246)XORI
246		FORMAT(/,12X,'CORRECTIONS MADE FOR SMALL BEAM ON',
	1	' LARGE CRYSTAL CENTERED AT:'/12X,3F13.3)
	ENDIF
C


C
C PRINT OUT THE PLANES FORMING CRYSTAL EDGES
C
	CALL GETEDGES(TEDGE,NTEMP)
	IF(IFATAL .EQ. 1)RETURN
C
C SET XMIN AND XMAX FROM CORNERS (AS PER ABSORB4.0)
C
	DO I=1,3			! INITIAL
		XMAX(I)=CORNER(1,I)
		XMIN(I)=XMAX(I)
	ENDDO
	DO I=2,NCORN
		DO J=1,3
			IF(CORNER(I,J) .GT. XMAX(J))XMAX(J)=CORNER(I,J)
			IF(CORNER(I,J) .LT. XMIN(J))XMIN(J)=CORNER(I,J)
		ENDDO
	ENDDO
	RETURN
	END
C***************************************************************************
C
	SUBROUTINE READ_XYZ_FACE
C
C SUBROUTINE TO READ TRIPLETS OF CORNERS IN OLD FORMAT FROM FACE_STORE
C
	INCLUDE 'Crystalmodel.inc'
	REAL A(3,3)
	INCLUDE 'Facestore.inc'
	CHARACTER*256 ETEXT
C
	DO 122 I=1,I1
	READ(FACE_STORE(I),*,END=900,ERR=999)A
C
C ADDED ORIGIN SHIFT 23-FEB-2012
C
	DO K=1,3
		DO J=1,3
			A(K,J)=A(K,J)+MODEL_ORIGIN(K)
		ENDDO
	ENDDO


C
C CHECK FOR MIN AND MAX VALUES OF COORDINATES FOR TEMPORARY ORIGIN
C
	IF(I .EQ. 1)THEN
		DO K=1,3
			XMAX(K)=A(K,1)
			XMIN(K)=A(K,1)
		ENDDO
	ENDIF
	DO J=1,3
		DO K=1,3
		  IF(XMIN(K) .GT. A(K,J))XMIN(K)=A(K,J)
		  IF(XMAX(K) .LT. A(K,J))XMAX(K)=A(K,J)
		ENDDO
	ENDDO
C
C NEW EXPRESSIONS FOR EQUATION COEFFICIENTS
C
	B(I,1)=(A(2,2)*A(3,3))-(A(3,2)*A(2,3))-(A(2,1)*A(3,3))+
     1         (A(3,1)*A(2,3))+(A(2,1)*A(3,2))-(A(3,1)*A(2,2))
	B(I,2)=-(A(1,2)*A(3,3))+(A(3,2)*A(1,3))+(A(1,1)*A(3,3))-
     1         (A(3,1)*A(1,3))-(A(1,1)*A(3,2))+(A(3,1)*A(1,2))
	B(I,3)=(A(1,2)*A(2,3))-(A(2,2)*A(1,3))-(A(1,1)*A(2,3))+
     1         (A(2,1)*A(1,3))+(A(1,1)*A(2,2))-(A(2,1)*A(1,2))
	B(I,4)=-A(1,1)*(A(2,2)*A(3,3)-A(3,2)*A(2,3))+
     1          A(1,2)*(A(2,1)*A(3,3)-A(3,1)*A(2,3))-
     2          A(1,3)*(A(2,1)*A(3,2)-A(3,1)*A(2,2))
C
C NORMALISE EQUATION
C
	cmax=0.
	do k=1,4
		if(abs(b(i,k)) .gt. abs(cmax))cmax=b(i,k)
	enddo
	do k=1,4
		b(i,k)=b(i,k)/cmax
	enddo
C
122 	CONTINUE
C
C CALCULATE COORDINATES OF POINT WITHIN CRYSTAL FROM MIN & MAX VALUES
C
	DO I=1,3
		XORI(I)=(XMIN(I)+XMAX(I))/2.
	ENDDO
C
	RETURN
C
C ERRORS ON READING FACE CARDS
C
900	WRITE(ETEXT,"('UNEXPECTED END OF DATA ON FACE CARD NO. ',I2)")I
	CALL ERROR(ETEXT)
	RETURN
999	WRITE(ETEXT,"('FORMAT ERROR ON FACE CARD NO. ',I2)")I
	CALL ERROR(ETEXT)
	RETURN
C
	END
C****************************************************************************
	SUBROUTINE READ_XYZ_CORNER
C
C NEW SUBROUTINE AUGUST 2002 TO READ SINGLE CORNERS AND BUILD FACE EQUATIONS
C
C CORNER COORDS FROM INPUT ARE STORED IN FACE_STORE!!
	INCLUDE 'Crystalmodel.inc'
	REAL A(3,3)
	INCLUDE 'Facestore.inc'
	INCLUDE 'dac.inc'
	CHARACTER*256 ETEXT
C
C LOOP OVER STORED CORNER COORDS AND READ INTO ARRAY CORNER
	DO I=1,NCORN
		READ(FACE_STORE(I),*,ERR=999,end=900)(CORNER(I,J),J=1,3)
C10		FORMAT(3F10.0)
	ENDDO
C
C  IF DAC CRYSTAL SPECIFIED, DOUBLE THE CORNERS AND SET THE Y COORDS
	IF(IXANVIL .NE. 0)THEN
C
C FIRST CALC THE Y-COORDS
		IF(IXANVIL .EQ. 1)THEN
			Y1=0.
			Y2=TCRYSTAL
		ELSE
			Y1=TG-TCRYSTAL
			Y2=TG
		ENDIF
C
C NOW DUPLICATE CORNERS AND APPLY Y
		DO I=1,NCORN
			CORNER(I,2)=Y1
			CORNER(NCORN+I,1)=CORNER(I,1)					
			CORNER(NCORN+I,2)=Y2				
			CORNER(NCORN+I,3)=CORNER(I,3)					
		ENDDO
		NCORN=2*NCORN
	ENDIF




C
C ADDED ORIGIN SHIFT 23-FEB-2012
C
	DO I=1,NCORN
		DO J=1,3
			CORNER(I,J)=CORNER(I,J)+MODEL_ORIGIN(J)
		ENDDO
	ENDDO

C
C  AVERAGE ALL CORNER COORDS TO GET A POINT INSIDE CRYSTAL: STORE AS XORI
C
	DO I=1,NCORN
		DO J=1,3
			XORI(J)=XORI(J)+CORNER(I,J)
		ENDDO
	ENDDO
	DO I=1,3
		XORI(I)=XORI(I)/NCORN
	ENDDO
C
C LOOP OVER ALL POSSIBLE TRIPLETS OF CORNERS TO CONSTRUCT PLANES
	I1=0		! NUMBER OF PLANES
	DO I=1,NCORN-2
		A(1,1)=CORNER(I,1)
		A(2,1)=CORNER(I,2)
		A(3,1)=CORNER(I,3)
	    DO J=I+1,NCORN-1
			A(1,2)=CORNER(J,1)
			A(2,2)=CORNER(J,2)
			A(3,2)=CORNER(J,3)
	    DO K=J+1,NCORN
			A(1,3)=CORNER(K,1)
			A(2,3)=CORNER(K,2)
			A(3,3)=CORNER(K,3)
	I1=I1+1
	B(I1,1)=(A(2,2)*A(3,3))-(A(3,2)*A(2,3))-(A(2,1)*A(3,3))+
     1         (A(3,1)*A(2,3))+(A(2,1)*A(3,2))-(A(3,1)*A(2,2))
	B(I1,2)=-(A(1,2)*A(3,3))+(A(3,2)*A(1,3))+(A(1,1)*A(3,3))-
     1         (A(3,1)*A(1,3))-(A(1,1)*A(3,2))+(A(3,1)*A(1,2))
	B(I1,3)=(A(1,2)*A(2,3))-(A(2,2)*A(1,3))-(A(1,1)*A(2,3))+
     1         (A(2,1)*A(1,3))+(A(1,1)*A(2,2))-(A(2,1)*A(1,2))
	B(I1,4)=-A(1,1)*(A(2,2)*A(3,3)-A(3,2)*A(2,3))+
     1          A(1,2)*(A(2,1)*A(3,3)-A(3,1)*A(2,3))-
     2          A(1,3)*(A(2,1)*A(3,2)-A(3,1)*A(2,2))
C
C NORMALISE EQUATION
C
	cmax=0.
	do kp=1,4
		if(abs(b(i1,kp)) .gt. abs(cmax))cmax=b(i1,kp)
	enddo
C TRAP DUPLICATE CORNERS WHICH PRODUCE CMAX=0.
	IF(ABS(CMAX) .LT. 0.00001)THEN
			WRITE(ETEXT,"(' DUPLICATE CORNERS NOS ',3I6)")I,J,K
			CALL ERROR(ETEXT)
			RETURN
	ENDIF
	do kp=1,4
		b(i1,kp)=b(i1,kp)/cmax
	enddo
C SET CORRECT PARITY ON COEFFS BEFORE TESTING PLANE AGAINST CORNERS
	  SUM=0.
	  DO JJ=1,3
	    SUM=SUM+B(I1,JJ)*XORI(JJ)
	  ENDDO
	  IF(SUM+B(I1,4) .LT. 0.0)THEN
	    DO JJ=1,4
	      B(I1,JJ)=-1.0*B(I1,JJ)
	    ENDDO
	  ENDIF

C	WRITE(20,199)I,J,K,(B(I1,JJ),JJ=1,4)			! FOR DEBUGGING
C199	FORMAT('  GENERATED: ',3I5,4F12.6)
C
C TEST THIS PLANE AGAINST ALL CORNERS
C
C
	DO M=1,NCORN
	  SUM=0.
	  DO M1=1,3
		SUM=SUM+B(I1,M1)*CORNER(M,M1)
	  ENDDO
	  SUM=SUM+B(I1,4)
	  IF(SUM .LT. -0.001)THEN
			I1=I1-1	! EFFECTIVELY DELETES PLANE
C			WRITE(20,198)I,J,K,M						! FOR DEBUGGING
C198			FORMAT('  REJECTED: ',3I5,' BY CORNER',I5)
			GOTO 100
	  ENDIF
	ENDDO
C
C TEST THIS PLANE AS DUPLICATE OF PREVIOUS PLANES (HAPPENS IF PLANE
C INCLUDES MORE THAN 3 CORNERS)
C
	DO M=1,I1-1
		DO M1=1,4						
			DIFF=ABS(B(M,M1)-B(I1,M1))
			AVE=ABS((B(M,M1)+B(I1,M1))/2.)
			IF(DIFF .GT. 0.05*AVE)GOTO 200
		ENDDO
		I1=I1-1		! HERE IF IDENTICAL TO A PREVIOUS PLANE
C			WRITE(20,196)I,J,K,M				! FOR DEBUGGING
C196			FORMAT('  REJECTED: ',3I5,' BY PLANE',I5)
		GOTO 100
200	ENDDO
C		WRITE(20,197)I,J,K,I1					!FOR DEBUGGING
C197		FORMAT('  PASSED: ',3I5,' NOW PLANE ',I3)
C
C END OF LOOP OVER TRIPLETS
100		ENDDO
	  ENDDO
	ENDDO
C
	RETURN
C
C ERRORS ON READING CORNER CARDS
C
900	WRITE(ETEXT,"('UNEXPECTED END OF DATA ON CORNER CARD NO. ',I2)")I
	CALL ERROR(ETEXT)
	RETURN
999	WRITE(ETEXT,"('FORMAT ERROR ON CORNER CARD NO. ',I2)")I
	CALL ERROR(ETEXT)
	RETURN
C
	END

C****************************************************************************
	SUBROUTINE READ_HKL
C
C SUBROUTINE TO READ FACE DATA AS HKL AND D FROM FACE_STORE
C AND GENERATE FACE EQUATIONS
C
	INCLUDE 'Crystalmodel.inc'
	INCLUDE 'Unitcell.inc'
	REAL HPHI(3)
	INTEGER IHT(3)
	INCLUDE 'Facestore.inc'
	INCLUDE 'dac.inc'
	CHARACTER ETEXT*256
C
C NEEDS UB MATRIX: TEST FOR IT
C	
	IF(IUB .NE. 3)THEN
			WRITE(ETEXT,10)
10	FORMAT('UB MATRIX NOT PRESENT: NEEDED TO INTEPRET HKL CARDS')
	CALL ERROR(ETEXT)
	RETURN
	ENDIF
C
C NOW LOOP OVER FACES
C
	DO I=1,I1
		READ(FACE_STORE(I),*,ERR=999,END=900)IHT,B(I,4)


C12 		FORMAT (3I5,F8.0)
C
C TRANSFORM IH INTO XYZ BUSING-LEVY: UB IS ALREADY BUSING-LEVY
C
		RLEN=0.
		DO J=1,3
			HPHI(J)=0.
			DO K=1,3
				HPHI(J)=HPHI(J)+UB(J,K)*IHT(K)
			ENDDO
			RLEN=RLEN+HPHI(J)*HPHI(J)
		ENDDO
C
C NORMALISE HPHI TO UNIT VECTOR
C
		RLEN=SQRT(RLEN)
		DO J=1,3
			B(I,J)=HPHI(J)/RLEN
		ENDDO
		B(I,4)=-1.0*B(I,4)		! CORRECTION DEC 2003
	ENDDO			! END OF LOOP OVER FACE CARDS IN STORE
C
C ADDITIONAL CODE FOR DAC CRYSTAL: ADDS TWO PLANES PARALLEL TO THE CULET FACES
C 3-MAY-2012
C WHAT THIS DOES IS TO ADD THE TWO PLANES AT Y = +/-TCRYSTAL 
C AND THEN ADJUSTS THE MODEL_ORIGIN TO THE MID-POINT OF THE CRYSTAL IN Y COORDS
C THIS ENSURES WE HAVE A POINT INSIDE THE CRYSTAL, EVEN IF CRYSTAL IS ON
C THE DIFFRACTED BEAM ANVIL
C
	IF(IXANVIL .NE. 0)THEN
		DO J=I1+1,I1+2
			B(J,1)=0.
			B(J,3)=0.
		ENDDO
		B(I1+1,2)=-2.0/TCRYSTAL
		B(I1+1,4)=1.0
		B(I1+2,2)=2.0/TCRYSTAL
		B(I1+2,4)=1.0
		I1=I1+2	
		IF(IXANVIL .EQ. 1)THEN
			MODEL_ORIGIN(2)=MODEL_ORIGIN(2)+TCRYSTAL/2.
		ELSE
			MODEL_ORIGIN(2)=MODEL_ORIGIN(2)+TG-TCRYSTAL/2.
		ENDIF
	ENDIF
C
C FOLLOWING CHANGES 23 FEB 2012 TO ACCOMODATE ORIGIN OFFSET
C
C FIRST APPLY THE OFFSET TO THE PLANE EQUATIONS...ONLY SHIFTS THE CONSTANT TERM
C
	DO I=1,I1
		DO J=1,3
			B(I,4)=B(I,4)-MODEL_ORIGIN(J)*B(I,J)
		ENDDO
C NOW RENORMALISE THE EQUATIONS TO D=1
		DO J=1,4
			IF(B(I,4) .GT. 0.01)B(I,J)=B(I,J)/B(I,4)
		ENDDO				
	ENDDO 
C
C SET XORI TO MODEL OFFSET AS XORI MUST BE POINT INSIDE CRYSTAL
	DO I=1,3
		XORI(I)=MODEL_ORIGIN(I)
	ENDDO
	RETURN
C
C ERRORS ON READING FACE CARDS
C
900	WRITE(ETEXT,"('UNEXPECTED END OF DATA ON FACE CARD NO. ',I2)")I
	CALL ERROR(ETEXT)
	RETURN
999	WRITE(ETEXT,"('FORMAT ERROR ON FACE CARD NO. ',I2)")I
	CALL ERROR(ETEXT)
	RETURN
C
	END				
C****************************************************************************
        BLOCK DATA GAUSSIAN
c
c data for gaussian grid intervals
C VALUES FOR UP TO 16 GRID CHECKED DEC 2003 AGAINST VALUES FROM WILEY WEB SITE
C AND VALUES FOR 32 POINTS ADDED
c
	include 'griddata.inc'
C
      data gauss(1,1),gweight(1,1)/0.0,2.0/
      data (gauss(2,i),i=1,2)/-.5773503,0.5773503/
      data (gweight(2,i),i=1,2)/1.0,1.0/
      data (gauss(3,i),i=1,4)/-.8611363,-.339981,0.339981,0.8611363/
      data (gweight(3,i),i=1,4)/0.3478548,0.6521451,0.6521451,0.3478548/
      data (gauss(4,i),i=1,4)/-.9602899,-.7966665,-.5255324,-.1834346/
      data (gweight(4,i),i=1,4)/0.1012285,0.222381,0.3137066,0.3626838/
      data (gauss(4,i),i=5,8)/0.1834346,0.5255324,0.7966665,0.9602899/
      data (gweight(4,i),i=5,8)/0.3626838,0.3137066,0.222381,0.1012285/
      data (gauss(5,i),i=1,4)/-.9894009,-.9445750,-.8656312,-.7554044/
      data (gauss(5,i),i=5,8)/-.6178762,-.4580168,-.2816036,-.0950125/
      data (gauss(5,i),i=9,12)/0.0950125,0.2816036,0.4580168,0.6178762/
      data (gauss(5,i),i=13,16)/0.7554044,0.8656312,0.9445750,0.9894009/
      data (gweight(5,i),i=1,4)/0.0271525,0.0622535,0.0951585,0.1246290/
      data (gweight(5,i),i=5,8)/0.1495960,0.1691565,0.1826034,0.1894506/
      data (gweight(5,i),i=9,12)/0.1894506,0.1826034,
	1							0.1691565,0.1495960/
      data (gweight(5,i),i=13,16)/0.1246290,0.0951585,
     1                            0.0622535,0.0271525/
C
C START 32-GRID
      data (gauss(6,i),i=1,4)/-.9972639,-.9856115,-.9647623,-.9349060/
      data (gauss(6,i),i=5,8)/-.8963212,-.8493676,-.7944838,-.7321821/
      data (gauss(6,i),i=9,12)/-.6630443,-.5877158,-.5068999,-.4212351/
      data (gauss(6,i),i=13,16)/-.3318686,-.2392874,-.1444720,-.0483077/
      data (gauss(6,i),i=17,20)/0.0483077,0.1444720,0.2392874,0.3318686/
      data (gauss(6,i),i=21,24)/0.4212351,0.5068999,0.5877158,0.6630443/
      data (gauss(6,i),i=25,28)/0.7321821,0.7944838,0.8493676,0.8963212/
      data (gauss(6,i),i=29,32)/0.9349060,0.9647623,0.9856115,0.9972639/

      data (gweight(6,i),i=1,4)/0.0070186,0.0162744,0.0253921,0.0342739/
      data (gweight(6,i),i=5,8)/0.0428359,0.0509981,0.0586841,0.0658222/
      data (gweight(6,i),i=9,12)/0.0723458,0.0781939,
	1							0.0833119,0.0876521/
      data (gweight(6,i),i=13,16)/0.0911739,0.0938444,
	1							0.0956387,0.0965400/
      data (gweight(6,i),i=17,20)/0.0965400,0.0956387,
	1							0.0938444,0.0911739/
      data (gweight(6,i),i=21,24)/0.0876521,0.0833119,
	1							0.0781939,0.0723458/
      data (gweight(6,i),i=25,28)/0.0658222,0.0586841,
	1							0.0509981,0.0428359/
      data (gweight(6,i),i=29,32)/0.0342739,0.0253921,
	1							0.0162744,0.0070186/



C
        END
C
	SUBROUTINE SETGRID
C
C SUBROUTINE TO DETERMINE GAUSSIAN GRID POINTS ON THE CRYSTAL
C 
	INCLUDE 'Crystalmodel.inc'
	include 'griddata.inc'
	include 'files.inc'
	real XTEST(3)
	CHARACTER TEXT*80
c
c convert ngrid values into no. of steps along eaxh axis
c
	DO I=1,3
	  NPT(I)=NINT(2.0**NGRID(I))
	  NGRID(I)=NGRID(I)+1
	ENDDO
C
C SET INDICATOR FOR PRINTING MIN/MAX VALUES
C
	JPRT=0
	IF(IGRID .EQ. 1 .OR. IGRID .EQ. 3)THEN
	   JPRT=1
	   WRITE(15,1)TITLE
1	   FORMAT(//10X,'GAUSSSIAN GRID LIMITS FOR ',A80)
	ENDIF
C
C (ALREADY HAVE MIN,MAX VALUES OF X IN XMIN(1),XMAX(1) )
C  SET UP GRID INTERVALS ON X
C
	IF(JPRT .EQ. 1)WRITE(15,501)XMIN(1),XMAX(1)
501	FORMAT(//10X,'XMIN = ',F10.4,10X,'XMAX = ',F10.4/)
	XZERO= (XMAX(1)+XMIN(1))/2.
	XINC = (XMAX(1)-XMIN(1))/2.
	DO I=1,NPT(1)
	  XPT(I)= XZERO+XINC*GAUSS(NGRID(1),I)
	  XW(I) = XINC*GWEIGHT(NGRID(1),I)
C
C AT THIS X VALUE FIND MIN AND MAX Y VALUES BY LOOPING OVER
C EDGE PAIRS STORED IN IEDGE AND SOLVING FOR INTERSECTION
C WITH PLANE X=XPT(I)
C
	  XTEST(1)=XPT(I)
	  YMIN=  1.0E6
	  YMAX= -1.0E6
	  DO II=1,NEDGE
	    IA=IEDGE(II,1)
	    IB=IEDGE(II,2)
	    DET=B(IA,2)*B(IB,3)-B(IA,3)*B(IB,2)
C
C IF DET=0 THEN NO INTERSECTION 
	    IF(ABS(DET) .LT. 1.0E-5)GOTO100
	    TEMPY= -1.0*(B(IA,4)+B(IA,1)*XPT(I))
	    TEMPZ= -1.0*(B(IB,4)+B(IB,1)*XPT(I))
	    XTEST(2)=(B(IB,3)*TEMPY-B(IA,3)*TEMPZ)/DET
	    XTEST(3)=(B(IA,2)*TEMPZ-B(IB,2)*TEMPY)/DET
	    IF(INCRYSTAL(XTEST) .NE. -1)THEN
	      IF(XTEST(2) .LT. YMIN)YMIN=XTEST(2)
	      IF(XTEST(2) .GT. YMAX)YMAX=XTEST(2)
	    ENDIF
100	  ENDDO
C
C GOT MIN AND MAX Y AT THIS X VALUE: SET UP Y-GRID AT THIS X
C
	IF(JPRT .EQ. 1)WRITE(15,502)XPT(I),YMIN,YMAX
502	FORMAT(/10X,'AT X = ',F10.4,' YMIN = ',F10.4,' YMAX = ',F10.4/)
	YZERO= (YMAX+YMIN)/2.
	YINC = (YMAX-YMIN)/2.
	  DO J=1,NPT(2)
	      YPT(I,J)= YZERO+YINC*GAUSS(NGRID(2),J)
	      YW(I,J) = YINC*GWEIGHT(NGRID(2),J)
C
C AT THESE X,Y COORDS FIND MIN AND MAX Z VALUES: LOOP OVER PLANES
C
	      ZMIN=  1.0E6
	      ZMAX= -1.0E6
	      XTEST(2)=YPT(I,J)
	      DO JA=1,I1
C
C TRAP CASE OF PLANE PARALLEL TO LINE
C
		IF(ABS(B(JA,3)) .LT. 1.0E-5)GOTO110
		XTEST(3)= -1.0*(B(JA,1)*XTEST(1)+B(JA,2)*XTEST(2)+
     1			       B(JA,4))/B(JA,3)
		IF(INCRYSTAL(XTEST) .NE. -1)THEN
C
C POINT IN CRYSTAL OR ON SURFACE - CHECK FOR MIN OR MAX
C
		  IF(XTEST(3) .LT. ZMIN)ZMIN=XTEST(3)
		  IF(XTEST(3) .GT. ZMAX)ZMAX=XTEST(3)
		ENDIF
110	      ENDDO
C
C GOT MIN AND MAX Z AT THIS X,Y: SET UP Z GRID AT THIS X,Y
C
	IF(JPRT .EQ. 1)WRITE(15,503)XPT(I),YPT(I,J),ZMIN,ZMAX
503	FORMAT(10X,'AT X = ',F10.4,' Y = ',F10.4,
     1             ' ZMIN = ',F10.4,' ZMAX = ',F10.4)
	      ZZERO=(ZMAX+ZMIN)/2.
	      ZINC=(ZMAX-ZMIN)/2.
	      DO K=1,NPT(3)
		ZPT(I,J,K)= ZZERO+ZINC*GAUSS(NGRID(3),K)
	        ZW(I,J,K) = ZINC*GWEIGHT(NGRID(3),K)
C
C STORE NUMERATORS FOR EQNS 9 AND 10 OF BURNHAM FOR THIS GRID POINT
C BY LOOPING OVER PLANES
C
		DO KK=1,I1
		   TEMP= B(KK,1)*XPT(I)+B(KK,2)*YPT(I,J)
     1                             +B(KK,3)*ZPT(I,J,K)
		   NUMER(I,J,K,KK)=-1.0*(TEMP+B(KK,4))
		ENDDO
	      ENDDO
	  ENDDO
	ENDDO
C
C GET CRYSTAL VOLUME
C
	CALL XVOLUME(XVOL)
c
	IF(IGRID .GT. 1)CALL GWRITE
	return
	end
c
c	options/extend
	subroutine gwrite
c
c -writes out xyz coords of gaussian grid points 
c
	include 'files.inc'
	include 'griddata.inc'
	include 'Crystalmodel.inc'
c
	WRITE(15,10)TITLE
10	format(//'    COORDINATES OF GAUSSIAN GRID POINTS FOR ',A80,//
     1	9x,'X',10x,'Y',20x,'Z COORDINATES')
c
c
	if(npt(3) .lt. 8)then
		izpt=npt(3)
	else
		izpt=8
	endif
c
	do i=1,npt(1)
	  do j=1,npt(2)
	    write(15,20)xpt(i),ypt(i,j),(zpt(i,j,k),k=1,izpt)
20	    format(2x,f10.1,',',f10.1,':',8f10.1)
	    if(npt(3) .gt. 8)write(15,30)(zpt(i,j,k),k=9,npt(3))
30		format(24x,8f10.1)
	  enddo
	enddo
	return
	end
C
	SUBROUTINE GETCORNER(IA,IB,IC,CTEMP,IFND)
C
C CALCULATES INTERSECTION OF THE THREE PLANES DENOTED
C BY INTEGERS I1,I2,I3 POINTING AT ARRAY B. RETURNS
C IFND=1 IF CORNER FOUND, IFND=0 ON ERROR OR NO COMMON INTERSECTION
C
	INCLUDE 'Crystalmodel.inc'
	REAL,PARAMETER::DOUBLE=SELECTED_REAL_KIND(p=13,r=200)
	REAL(KIND=DOUBLE):: CORN(3),EQN(3,3),EQNI(3,3),RHS(3),det
	real CTEMP(3)
	INTEGER IPLANE(3)
C
	IPLANE(1)=IA
	IPLANE(2)=IB
	IPLANE(3)=IC
C
C LOAD X,Y,Z COEFFS OF PLANE INTO EQN
C
	DO L=1,3
		DO M=1,3
			EQN(L,M)=B(IPLANE(L),M)
		ENDDO
		RHS(L)= -B(IPLANE(L),4)
	ENDDO
C
C NOW INVERT EQN
C
	CALL MINV38(EQN,EQNI,1.0D-7,DET,IERR)
	IF(IERR .NE. 0)THEN
		IFND=0
	ELSE
		CORN=MATMUL(EQNI,RHS)
		IFND=1
		DO I=1,3
			CTEMP(I)=CORN(I)
		ENDDO
	ENDIF
C
	RETURN
	END
C
C
	FUNCTION INCRYSTAL(COORD)
C
C FUNCTION TO DETERMINE IF POINT GIVEN IN C IS INSIDE, ON SURFACE
C OR OUTSIDE CRYSTAL
c
C
C RETURNS 1 IF INSIDE
C	  0 IF ON SURFACE (ABS(SUM) < 1.0E-3)
C	 -1 IF OUTSIDE
C 
	INCLUDE 'crystalmodel.inc'
	REAL COORD(3)
C
	ERR=1.0E-3
	ISURF=0
C
C LOOP OVER PLANES (INDEX I)
C
  	DO I=1,I1
	  SUM=0.
	  DO J=1,3
		SUM=SUM+B(I,J)*COORD(J)
	  ENDDO
	  SUM=SUM+B(I,4)
C
C FIRST CHECK IF OUTSIDE
C
	  IF(SUM .LT. -1.*ERR)THEN
		INCRYSTAL=-1
		RETURN
	  ELSE
		IF(SUM .LT. ERR)THEN
		  ISURF=ISURF+1
		ENDIF
	  ENDIF
	ENDDO	
C
C END OF LOOP OVER PLANES: GET HERE IF POINT INSIDE OR ON
C ALL CRYSTAL PLANES - DISTINGUISH TWO CASES
C
	IF(ISURF .GT. 0)THEN
		INCRYSTAL=0
	ELSE
		INCRYSTAL=1
	ENDIF
	RETURN
	END
C
C
	SUBROUTINE XVOLUME(VOLX)
C
C CALCULATES CRYSTAL VOLUME BY SUMMATION OF WEIGHTING FUNCTIONS
C OVER GAUSSIAN GRID
C
	INCLUDE 'griddata.inc'
	include 'crystalmodel.inc'

C
	VOLX=0.
	DO I=1,NPT(1)
	  SUMY=0.
	  DO J=1,NPT(2)
	    SUMZ=0.
	    DO K=1,NPT(3)
		SUMZ=SUMZ+ZW(I,J,K)
	    ENDDO
	    SUMY=SUMY+YW(I,J)*SUMZ
	  ENDDO
	  VOLX=VOLX+XW(I)*SUMY
	ENDDO
	RETURN
	END
C
C 
	SUBROUTINE GETEDGES(TEDGE,NTEMP)
C
C SUBROUTINE TO STORE INDECES OF THE PAIRS OF INTERSECTING PLANES
C THAT FORM EDGES OF THE CRYSTAL
C
C ARRAY TEDGE HOLDS THE INDECES OF EACH TRIPLE OF PLANES FORMING
C A CORNER. IF A PAIR OF PLANE INDECES APPEARS TWICE THEN THAT 
C PAIR MUST FORM AN EDGE OF THE CRYSTAL

	INTEGER TEDGE(200,40),NTEMP(200)
	INCLUDE 'Crystalmodel.inc'
	include 'files.inc'
	INCLUDE 'DAC.INC'
	CHARACTER ETEXT*256
C
	NEDGE=0
C 
	DO I=1,NCORN
	 DO II=1,NTEMP(I)-1
C
	   DO J=I+1,NCORN
	    DO JJ=1,NTEMP(J)-1
C
C LOOK FOR FIRST MATCH
C
		IF(TEDGE(I,II) .EQ. TEDGE(J,JJ))THEN
C
C GOT FIRST MATCH - LOOK FOR SECOND
C
		  DO III=II+1,NTEMP(I)
		    DO JJJ=JJ+1,NTEMP(J)
			IF(TEDGE(I,III) .EQ. TEDGE(J,JJJ))THEN
C
C GOT SECOND MATCH - STORE IT
C
			  NEDGE=NEDGE+1
	    		  IF(NEDGE .GT. 200)THEN
				CALL WRITE_CRYSTAL_DATA(IPRT)
	  			write(ETEXT,10)
10	FORMAT('DIMENSION OF IEDGE EXCEEDED IN GETEDGES: ',
	1			'CHECK VALIDITY OF CRYSTAL MODEL')
	  			CALL ERROR(ETEXT)
				RETURN
			  ENDIF
		 	  IEDGE(NEDGE,1)=TEDGE(I,II)
			  IEDGE(NEDGE,2)=TEDGE(I,III)
			  GOTO90
			ENDIF
		    ENDDO
		  ENDDO
		ENDIF
	    ENDDO
90	   ENDDO
	 ENDDO
	ENDDO
C
C WRITE OUT EDGES
C
	IF(ISMALL .EQ. 0)THEN
		WRITE(IPRT,200)NEDGE
200	FORMAT(//10X,'THE FOLLOWING PAIRS OF PLANES FORM THE ',I3,
     1  ' EDGES OF THE CRYSTAL:'/)
	WRITE(IPRT,210)(IEDGE(I,1),IEDGE(I,2),I=1,NEDGE)
210	FORMAT(9(3X,I2,' &',I2,','))
	ENDIF
	RETURN
	END
C
c
 
C********************************************************************

	SUBROUTINE SETGRID_FILLG
C
C SUBROUTINE TO DETERMINE GAUSSIAN GRID POINTS ON A CRYSTAL THAT FILLS
C THE GASKET HOLE
C
C THE GRID SETUP IS FORCED TO BE INEFFICIENT BECAUSE X HAS TO BE CHOSEN FIRST
C 
	INCLUDE 'files.inc'
	include 'DAC.inc'
	include 'griddata.inc'
	include 'crystalmodel.inc'
	real XTEST(3)
	CHARACTER*80 TEXT
c
c convert ngrid values into no. of steps along eaxh axis
c
	DO I=1,3
	  NPT(I)=NINT(2.0**NGRID(I))
	  NGRID(I)=NGRID(I)+1
	ENDDO
C
C SET INDICATOR FOR PRINTING MIN/MAX VALUES
C
	JPRT=0
	IF(IGRID .EQ. 1 .OR. IGRID .EQ. 3)THEN
	   JPRT=1
	   WRITE(15,1)TITLE
1	   FORMAT(//10X,'GAUSSSIAN GRID LIMITS FOR ',A80)
	ENDIF
C
C  SET UP GRID INTERVALS ON X
C
	XMING=-1.*RGASKET
	XMAXG=RGASKET
C
	IF(JPRT .EQ. 1)WRITE(15,501)XMING,XMAXG
501	FORMAT(//10X,'XMIN = ',F10.4,10X,'XMAX = ',F10.4/)
	XZERO= 0.
	XINC =RGASKET
	DO I=1,NPT(1)
	  XPT(I)= XZERO+XINC*GAUSS(NGRID(1),I)
	  XW(I) = XINC*GWEIGHT(NGRID(1),I)
C
C AT THIS X VALUE MIN AND MAX Y VALUES ARE SET BY 0 AND THE 
C THICKNESS OF THE GASKET
C
	  XTEST(1)=XPT(I)
	  YMIN=  0.
	  YMAX= TG
C
C SET UP Y-GRID AT THIS X
C
	IF(JPRT .EQ. 1)WRITE(15,502)XPT(I),YMIN,YMAX
502	FORMAT(/10X,'AT X = ',F10.4,' YMIN = ',F10.4,' YMAX = ',F10.4/)
	YZERO= (YMAX+YMIN)/2.
	YINC = (YMAX-YMIN)/2.
	  DO J=1,NPT(2)
	      YPT(I,J)= YZERO+YINC*GAUSS(NGRID(2),J)
	      YW(I,J) = YINC*GWEIGHT(NGRID(2),J)
C
C AT THESE X,Y COORDS FIND MIN AND MAX Z VALUES: LOOP OVER PLANES
C
	      ZMAX=  SQRT(RGASKET*RGASKET - XPT(I)*XPT(I))	!CIRCULAR
	      ZMIN= -1.0*ZMAX
C SET UP Z GRID AT THIS X,Y
C
	IF(JPRT .EQ. 1)WRITE(15,503)XPT(I),YPT(I,J),ZMIN,ZMAX
503	FORMAT(10X,'AT X = ',F10.4,' Y = ',F10.4,
     1             ' ZMIN = ',F10.4,' ZMAX = ',F10.4)
	      ZZERO=(ZMAX+ZMIN)/2.
	      ZINC=(ZMAX-ZMIN)/2.
	      DO K=1,NPT(3)
		ZPT(I,J,K)= ZZERO+ZINC*GAUSS(NGRID(3),K)
	        ZW(I,J,K) = ZINC*GWEIGHT(NGRID(3),K)
C
	      ENDDO
	  ENDDO
	ENDDO
C
C GET CRYSTAL VOLUME
C
	CALL XVOLUME(XVOL)
c
	IF(IGRID .GT. 1)CALL GWRITE
	return
	end
C
	SUBROUTINE XYZ_TO_HKL
C
C SUBROUTINE BACK-CONVERTS XYZ EQUATIONS OF FACES TO HKL AND D
C
	INCLUDE 'crystalmodel.inc'
	include 'unitcell.inc'
	include 'files.inc'
	real hphi(3),h(3)
c 
c
	do i=1,i1
c
c copy equation
		sum=0
		do j=1,3
			hphi(j)= -1.0*b(i,j)   !CORRECTION DEC 2003
			sum=sum+hphi(j)*hphi(j)
		enddo
		sum=sqrt(sum)
c
c normalise hphi
		do j=1,3
			hphi(j)=hphi(j)/sum
		enddo
c
c do ub-1 * hphi
c
		do j=1,3
			h(j)=0.
			do k=1,3
				h(j)=h(j)+hphi(k)*ubti(k,j)
			enddo
		enddo
c
c re-normalise?
		hkld(i,4)=b(i,4)/sum/1000.	! factor of 1000. for micron to mm
		call roundhkl(h)
c
c write out
c
		do j=1,3
			hkld(i,j)=h(j)
		enddo
	enddo
	return
	end
c
	subroutine roundhkl(h)
c
	real h(3),k(3)
c
c find smallest, non-zero

c
c  -need to find big first
c
	big=abs(h(1))
	if(abs(h(2)) .gt. big)big=abs(h(2))
	if(abs(h(3)) .gt. big)big=abs(h(3))

	small=big
	do i=1,3
		if(abs(h(i)) .gt. 0.01)then
			if(abs(h(i)) .lt.  small)small=abs(h(i))
		endif
	enddo
c
c make norma copy
c
	do i=1,3
		h(i)=h(i)/small
	enddo
c
c happy to return fpt numbers
c
	return
	end										